<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ClassNotFoundException和NoClassDefFoundError区别</title>
    <url>/2020/06/28/ClassNotFoundException-and-NoClassDefFoundError/</url>
    <content><![CDATA[<p>NoClassDefFoundError是一个错误(Error)，而ClassNotFoundException是一个异常，分别列出两者的产生原因以及解决方案。</p>
<a id="more"></a>

<h2 id="ClassNotFoundException"><a href="#ClassNotFoundException" class="headerlink" title="ClassNotFoundException"></a><strong>ClassNotFoundException</strong></h2><ul>
<li><strong>产生原因</strong></li>
</ul>
<p>Java支持使用<code>Class.forName</code>方法来动态地加载类，<strong>任意一个类的类名如果被作为参数传递给这个方法都将导致该类被加载到JVM内存中，如果这个类在类路径中没有被找到，那么此时就会在运行时抛出ClassNotFoundException异常。</strong></p>
<p>要解决这个问题很容易，唯一需要做的就是要确保所需的类连同它依赖的包存在于类路径中。当Class.forName被调用的时候，类加载器会查找类路径中的类，如果找到了那么这个类就会被成功加载，如果没找到，那么就会抛出ClassNotFountException，除了<code>Class.forName，ClassLoader.loadClass、ClassLOader.findSystemClass</code>在动态加载类到内存中的时候也可能会抛出这个异常。</p>
<p>另外还有一个导致ClassNotFoundException的原因就是：当一个类已经某个类加载器加载到内存中了，此时另一个类加载器又尝试着动态地从同一个包中加载这个类。</p>
<ul>
<li><strong>解决方案</strong></li>
</ul>
<p>由于类的动态加载在某种程度上是被开发者所控制的，所以他可以选择catch这个异常然后采取相应的补救措施。有些程序可能希望忽略这个异常而采取其他方法。还有一些程序则会终止程序然后让用户再次尝试前做点事情。</p>
<h2 id="NoClassDefFoundError"><a href="#NoClassDefFoundError" class="headerlink" title="NoClassDefFoundError"></a><strong>NoClassDefFoundError</strong></h2><ul>
<li><strong>产生原因</strong></li>
</ul>
<p>如果JVM或者ClassLoader实例尝试加载（可以通过正常的方法调用，也可能是使用new来创建新的对象）类的时候却找不到类的定义。<strong>要查找的类在编译的时候是存在的，运行的时候却找不到了。</strong></p>
<p><strong>最有可能的原因就是存在多个类加载器和多个目标类，即我们常说的Jar包冲突</strong></p>
<ul>
<li><strong>解决方案</strong></li>
</ul>
<p>使用Maven Helper 这个插件，可以排除掉大部分jar包冲突；</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mvn dependency:tree -Dverbose -Dincludes=:logback-classic</span><br></pre></td></tr></table></figure>

<h2 id="发生时机："><a href="#发生时机：" class="headerlink" title="发生时机："></a><strong>发生时机：</strong></h2><p>简单来说，NoClassDefFoundError和ClassNotFoundException都是由于在CLASSPATH下找不到对应的类而引起的，通常是缺少对应的jar包，不过，JVM认为：</p>
<ol>
<li>当应用运行时没有找到对应的引用，则会抛出NoClassDefFoundError；</li>
<li>调用Class.forName()、ClassLoader.findSystemClass()和ClassLoader.loadClass()等方法时可能会引起ClassNotFoundException；</li>
</ol>
<p>开发者经常遇到的情况是：ClassNotFoundException异常引起了NoClassDefFoundError。</p>
<p><strong>ClassNotFoundException发生在装入阶段。</strong> </p>
<p>当应用程序试图通过类的字符串名称，使用常规的三种方法装入类，但却找不到指定名称的类定义时就抛出该异常。</p>
<p><strong>NoClassDefFoundError：当目前执行的类已经编译，但是找不到它的定义时。</strong></p>
<p>也就是说你如果编译了一个类B，在类A中调用，编译完成以后，你又删除掉B，运行A的时候那么就会出现这个错误</p>
<p>加载时从外存储器找不到需要的class就出现ClassNotFoundException </p>
<p>连接时从内存找不到需要的class就出现NoClassDefFoundError</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://my.oschina.net/jasonultimate/blog/166932" target="_blank" rel="noopener">https://my.oschina.net/jasonultimate/blog/166932</a></p>
<p><a href="https://www.jianshu.com/p/93d0db07d2e3" target="_blank" rel="noopener">https://www.jianshu.com/p/93d0db07d2e3</a></p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>异常</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客</title>
    <url>/2020/01/18/First-Blog-Post/</url>
    <content><![CDATA[<p>It all started here</p>
<a id="more"></a>

<h3 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h3><p>新开一个个人博客用于知识管理，同时也会记录一些生活、想法、读书笔记等等。</p>
<p>以前一直在用有道云笔记进行知识管理，原因是同步起来十分方便，还可以跨平台跨设备，同时对markdown格式的支持比较友好。然而云笔记相比博客，缺少了分享和交流，同时博客也能用内容输出来促进自己的输入。</p>
<p><img src="/2020/01/18/First-Blog-Post/1548932548163.png" alt="1548932548163"></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
  <entry>
    <title>Spring Boot快速配置Druid数据库连接池</title>
    <url>/2020/03/13/druid-quick-start/</url>
    <content><![CDATA[<p>本文主要内容为在Spring Boot中配置Druid数据库连接池，并使用Druid部分特性</p>
<a id="more"></a>

<p>Druid是阿里巴巴开源的一款优秀的连接池，能够提供强大的监控和扩展功能，现在很多项目中都用到。下面将介绍如何在Spring Boot中配置并使用该连接池。</p>
<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><ul>
<li>Spring Boot: 2.1.3</li>
<li>Druid: 1.1.4</li>
<li>maven：3.6.0</li>
</ul>
<h2 id="maven引入"><a href="#maven引入" class="headerlink" title="maven引入"></a>maven引入</h2><p>Druid提供了spring-boot-srarter用来快速配置Druid</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.14<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="配置application-yml"><a href="#配置application-yml" class="headerlink" title="配置application.yml"></a>配置application.yml</h2><p>在application.properties或application.yml中配置相关属性，这里我用的是yml</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">    <span class="attr">datasource:</span></span><br><span class="line">        <span class="comment">#druid相关配置</span></span><br><span class="line">        <span class="attr">druid:</span></span><br><span class="line">          <span class="attr">url:</span> <span class="string">jdbc:mysql://127.0.0.1:3306/demo?characterEncoding=utf8</span></span><br><span class="line">          <span class="attr">username:</span> <span class="comment">#数据库用户名</span></span><br><span class="line">          <span class="attr">password:</span> <span class="comment">#用ConfigFilter加密后的密码         </span></span><br><span class="line">          <span class="attr">initial-size:</span> <span class="number">1</span> <span class="comment">#配置初始化大小</span></span><br><span class="line">          <span class="attr">min-idle:</span> <span class="number">1</span></span><br><span class="line">          <span class="attr">max-active:</span> <span class="number">20</span>   </span><br><span class="line">          <span class="attr">max-wait:</span> <span class="number">60000</span> <span class="comment">#获取连接等待超时时间          </span></span><br><span class="line">          <span class="attr">time-between-eviction-runs-millis:</span> <span class="number">60000</span> <span class="comment">#间隔多久进行一次检测，检测需要关闭的空闲连接     </span></span><br><span class="line">          <span class="attr">min-evictable-idle-time-millis:</span> <span class="number">300000</span> <span class="comment">#一个连接在池中最小生存的时间</span></span><br><span class="line">          <span class="attr">validation-query:</span> <span class="string">SELECT</span> <span class="string">'x'</span></span><br><span class="line">          <span class="attr">test-while-idle:</span> <span class="literal">true</span></span><br><span class="line">          <span class="attr">test-on-borrow:</span> <span class="literal">false</span></span><br><span class="line">          <span class="attr">test-on-return:</span> <span class="literal">false</span>  </span><br><span class="line">          </span><br><span class="line">          <span class="comment">#打开PSCache，并指定每个连接上PSCache的大小。oracle设为	true，mysql设为false。分库分表较多推			荐设置为false</span></span><br><span class="line">          <span class="attr">pool-prepared-statements:</span> <span class="literal">false</span> </span><br><span class="line">          <span class="attr">max-pool-prepared-statement-per-connection-size:</span> <span class="number">20</span></span><br><span class="line">          </span><br><span class="line">          <span class="attr">filters:</span> <span class="string">stat,config</span> <span class="comment">#监控统计拦截的filters</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#配置，并设置RSA公钥</span></span><br><span class="line">          <span class="comment">#获取秘钥过程详见 https://github.com/alibaba/druid/wiki/%E4%BD%BF%E7%94%A8ConfigFilter</span></span><br><span class="line">          <span class="attr">connectionProperties:</span> <span class="string">config.decrypt=true;config.decrypt.key=公钥的值</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">#监控设置</span></span><br><span class="line">          <span class="attr">stat-view-servlet:</span></span><br><span class="line">          <span class="comment">#是否启用StatViewServlet（监控页面）默认值为false（考虑到安全问题默认并未启动，如需启用建议设置密			码或白名单以保障安全）</span></span><br><span class="line">            <span class="attr">enabled:</span> <span class="literal">true</span> </span><br><span class="line">            <span class="attr">url-pattern:</span> <span class="string">/druid/*</span></span><br><span class="line">            <span class="attr">reset-enable:</span> <span class="literal">true</span> <span class="comment">#允许清空统计数据</span></span><br><span class="line">            <span class="attr">login-username:</span> <span class="string">druid</span> <span class="comment">#用户名</span></span><br><span class="line">            <span class="attr">login-password:</span> <span class="string">druid</span> <span class="comment">#密码</span></span><br><span class="line">            <span class="attr">allow:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span> <span class="comment">#白名单</span></span><br><span class="line">            <span class="attr">deny:</span> <span class="comment">#黑名单（优先级高于白名单）</span></span><br></pre></td></tr></table></figure>

<h2 id="如何配置多数据源"><a href="#如何配置多数据源" class="headerlink" title="如何配置多数据源"></a>如何配置多数据源</h2><ol>
<li>添加配置</li>
</ol>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">	<span class="attr">datasource:</span></span><br><span class="line">		<span class="attr">url:</span></span><br><span class="line">		<span class="attr">username:</span></span><br><span class="line">		<span class="attr">password:</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid 数据源配置，继承spring.datasource.* 配置，相同则覆盖</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">		<span class="attr">druid:</span></span><br><span class="line">			<span class="attr">initial-size:</span> <span class="number">1</span></span><br><span class="line">			<span class="attr">max-active:</span> <span class="number">5</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid 数据源 1 配置，继承spring.datasource.druid.* 配置，相同则覆盖</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">			<span class="attr">one:</span></span><br><span class="line">				<span class="attr">max-active:</span> <span class="number">10</span></span><br><span class="line">				<span class="attr">max-wait:</span> <span class="number">10000</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Druid 数据源 2 配置，继承spring.datasource.druid.* 配置，相同则覆盖</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line">			<span class="attr">two:</span> </span><br><span class="line">				<span class="attr">max-active:</span> <span class="number">20</span></span><br><span class="line">				<span class="attr">max-wait:</span> <span class="number">20000</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure>

<p><strong>强烈注意</strong>：Spring Boot 2.X 版本不再支持配置继承，多数据源的话每个数据源的所有配置都需要单独配置，否则配置不会生效</p>
<ol start="2">
<li>创建数据源</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Primary</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.one"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceOne</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(<span class="string">"spring.datasource.druid.two"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSourceTwo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> DruidDataSourceBuilder.create().build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>访问<code>http://localhost:8080/druid</code></p>
<p>进入登录页面，输入在stat-view-servlet:中配置的<code>login-username,login-password</code></p>
<p><img src="/2020/03/13/druid-quick-start/1552483854109.png" alt="1552483854109"></p>
<p>进入监控页面</p>
<p><img src="/2020/03/13/druid-quick-start/1552483947011.png" alt="1552483947011"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter" target="_blank" rel="noopener">https://github.com/alibaba/druid/tree/master/druid-spring-boot-starter</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>druid</tag>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title>数字签名和数字证书</title>
    <url>/2020/02/13/digitalSignature/</url>
    <content><![CDATA[<p>本文介绍了RSA加密和数字签名的基本原理，以及数字证书的由来。</p>
<a id="more"></a>

<h3 id="密钥加密"><a href="#密钥加密" class="headerlink" title="密钥加密"></a>密钥加密</h3><ul>
<li>A有一对成对的钥匙，一把为公钥，一把为私钥</li>
<li>公钥可以发送给别人，私钥只能自己保存</li>
<li>公钥私钥加密原理基于大质数分解</li>
<li>加密流程<ul>
<li>A将自己的公钥发送给B</li>
<li>这时，B要发送信息给A，B利用A的<strong>公钥加密</strong>要发送的内容然后发给A</li>
<li>A收到加密信息后利用自己的<strong>私钥解密</strong></li>
<li>只要A的私钥不泄露，信息就是安全的，即使落在别人手里，也无法解密。</li>
</ul>
</li>
</ul>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p><strong>步骤1：生成摘要（MD5）</strong></p>
<ul>
<li>A对信息使用hash函数（常用的MD5等）生成一个摘要（Digest）</li>
</ul>
<p><strong>步骤2：非对称加密（RSA1/2）</strong></p>
<ul>
<li>A对这个摘要用<strong>私钥加密</strong>，生成数字签名（signature）</li>
<li>A将数字签名附在要发送的信息后发送给B</li>
<li>B对数字签名用<strong>公钥解密</strong>，得到信息的摘要</li>
<li>B对信息本身使用hash函数，将得到的结果和上一步的摘要进行比对，如果两者一致，则说明信息未被改动</li>
<li>如果这时，C用自己的公钥替换了A的公钥，那么C就可以冒充A，让B用C的公钥解密C发送的信息</li>
<li>因此，这里需要一个具有公信力的机构（证书中心 certificate authority，简称CA）为公钥进行认证，这时就引出<strong>数字证书</strong></li>
</ul>
<p>RSA加密算法区别</p>
<table>
<thead>
<tr>
<th>开放平台签名算法名称</th>
<th>标准签名算法名称</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>RSA2</td>
<td>SHA256WithRSA</td>
<td>强制要求RSA密钥的长度至少为2048</td>
</tr>
<tr>
<td>RSA</td>
<td>SHA1WithRSA</td>
<td>对RSA密钥的长度不限制，推荐使用2048位以上</td>
</tr>
</tbody></table>
<h3 id="数字证书"><a href="#数字证书" class="headerlink" title="数字证书"></a>数字证书</h3><ul>
<li>证书中心用自己的私钥，对A的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）</li>
<li><strong>简而言之，数字证书就是对公钥进行加密的</strong></li>
<li>A今后发送加密信息时，除了附上数字签名外，再附上一个数字证书就可以保证自己的公钥不被冒充替换</li>
<li>实例：https协议<ul>
<li>请求： 客户端向服务端发送加密请求</li>
<li>响应：服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。</li>
<li>客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。</li>
</ul>
</li>
</ul>
<p><img src="/2020/02/13/digitalSignature/clipboard-1550059824367.png" alt="img"></p>
<p>如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。</p>
<p><img src="/2020/02/13/digitalSignature/clipboard-1550059839965.png" alt="img"></p>
<p>如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。</p>
<p><img src="/2020/02/13/digitalSignature/clipboard.png" alt="img"></p>
<p>如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li>阮一峰的<a href="http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html" target="_blank" rel="noopener">数字签名是什么</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>数字签名</tag>
        <tag>数字证书</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对接支付宝功能（二）当面付预下单</title>
    <url>/2020/02/01/java-alipay-2/</url>
    <content><![CDATA[<p>支付宝当面付预下单流程介绍以及生成二维码核心代码的源码分析</p>
<a id="more"></a>

<h3 id="当面付预下单"><a href="#当面付预下单" class="headerlink" title="当面付预下单"></a>当面付预下单</h3><h4 id="支付流程"><a href="#支付流程" class="headerlink" title="支付流程"></a>支付流程</h4><p><a href="https://docs.open.alipay.com/194/106078/" target="_blank" rel="noopener">接入指引</a></p>
<p>官方文档提供了接入的详细指引，调用流程和注意事项的介绍</p>
<p>这里放一张支付流程</p>
<p><img src="/2020/02/01/java-alipay-2/0dd5f9ae0c3da01ce2b9d6019efde979.png"></p>
<h4 id="加载alipay-SDK-jar包"><a href="#加载alipay-SDK-jar包" class="headerlink" title="加载alipay SDK jar包"></a>加载alipay SDK jar包</h4><p>首先，需要在项目中添加alipay-sdk-java和alipay-trade-sdk这两个包</p>
<p><img src="/2020/02/01/java-alipay-2/1549003941776.png"></p>
<p>将本地jar包通过maven发布到服务器上</p>
<p>为了读取在“/src/main/webapp/WEB-INF/lib”路径下的jar包，在pom文件中添加maven插件的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">encoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">encoding</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">extdirs</span>&gt;</span>$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib<span class="tag">&lt;/<span class="name">extdirs</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">compilerArguments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h4 id="支付宝生成二维码核心代码"><a href="#支付宝生成二维码核心代码" class="headerlink" title="支付宝生成二维码核心代码"></a>支付宝生成二维码核心代码</h4><p>修改自com.alipay.demo.trade.Main支付宝官方demo</p>
<p><strong>1. 设置支付相关参数</strong></p>
<p>外部订单号，订单标题，总金额，不可打折金额，卖家支付宝账号ID，订单描述，商户操作员编号，商户门店编号，业务扩展参数，支付超时，商品明细列表等参数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">outTradeNo, subject, totalAmount, undiscountableAmount, sellerId, body, operatorId, storeId, extendParams, timeoutExpress, goodsDetailList</span><br></pre></td></tr></table></figure>



<p><strong>2. 创建扫码支付请求builder，将上述参数通过调用链进行设置</strong></p>
<p>​    这里需要注意notifyUrl字段，支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlipayTradePrecreateRequestBuilder builder = <span class="keyword">new</span> AlipayTradePrecreateRequestBuilder().setXXX(aaa).setYYY(bbb)</span><br><span class="line">                      .setNotifyUrl(PropertiesUtil.getProperty(<span class="string">"alipay.callback.url"</span>))</span><br><span class="line"><span class="comment">// alipay.callback.url=希望回调通知的地址</span></span><br></pre></td></tr></table></figure>



<p><strong>3. 初始化tradeService</strong></p>
<p>从配置文件读取支付宝网关名，appId，商户私钥，格式（json），字符集（utf-8），支付宝公钥，签名类型等信息</p>
<p>这里用到了com.alipay.demo.trade包中的Configs和AlipayTradeServiceImpl来生成tradeService</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AlipayTradeServiceImpl <span class="title">init_tradeService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数</span></span><br><span class="line"><span class="comment">     *  Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是	  *  否在classpath目录</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Configs.init(<span class="string">"alipayinfo.properties"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 使用Configs提供的默认参数</span></span><br><span class="line"><span class="comment">     *  AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    tradeService = <span class="keyword">new</span> AlipayTradeServiceImpl.ClientBuilder().build();</span><br><span class="line">    <span class="keyword">return</span> tradeService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>4. 当面付预下单</strong></p>
<p>调用预下单方法，传入之前生成的builder对象，tradePrecreate内部会调用AlipayClient的execute方法，进行远程调用，返回一个response对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br></pre></td></tr></table></figure>



<p><strong>5.判断下单是否成功</strong></p>
<p><strong>5.1 预下单成功，生成二维码到指定路径</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">trade_precreate_success</span><span class="params">(AlipayF2FPrecreateResult result, String path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 简单打印应答</span></span><br><span class="line">    AlipayTradePrecreateResponse response = result.getResponse();</span><br><span class="line">    dumpResponse(response);</span><br><span class="line">    <span class="comment">// 本地生成二维码存放文件夹</span></span><br><span class="line">    File folder = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="keyword">if</span> (!folder.exists()) &#123;</span><br><span class="line">        folder.setWritable(<span class="keyword">true</span>);</span><br><span class="line">        folder.mkdirs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        生成二维码流程</span></span><br><span class="line"><span class="comment">        1. 根据外部订单号（outTradeNo）生成二维码存放路径（qrPath）</span></span><br><span class="line"><span class="comment">        2. 生成二维码到qrPath</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    String qrPath = String.format(path + <span class="string">"/qr-%s.png"</span>, response.getOutTradeNo());</span><br><span class="line">    String qrFileName = String.format(<span class="string">"qr-%s.png"</span>, response.getOutTradeNo());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成二维码图片到本地指定路径</span></span><br><span class="line">    File imageFile = ZxingUtils.getQRCodeImge(response.getQrCode(), <span class="number">256</span>, qrPath);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将本地路径的二维码图片上传到ftp服务器</span></span><br><span class="line">        FTPUtil.uploadFile(Lists.newArrayList(imageFile));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        logger.error(<span class="string">"上传二维码异常"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    logger.info(<span class="string">"qrPath:"</span> + qrPath);</span><br><span class="line">    <span class="comment">// 生成二维码的ftp Url</span></span><br><span class="line">    String qrUrl = PropertiesUtil.getProperty(<span class="string">"ftp.server.http.prefix"</span>) + imageFile.getName();</span><br><span class="line">    resultMap.put(<span class="string">"qrUrl"</span>, qrUrl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>流程总结整理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 1. 设置支付相关参数，具体可以参考demo中的说明</span></span><br><span class="line">    outTradeNo, subject, totalAmount, undiscountableAmount, sellerId, body, operatorId, storeId, extendParams, timeoutExpress, goodsDetailList</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 2. 创建扫码支付请求builder，设置请求参数</span></span><br><span class="line">    AlipayTradePrecreateRequestBuilder builder = <span class="keyword">new</span> AlipayTradePrecreateRequestBuilder()</span><br><span class="line">            .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) 		.setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body)</span><br><span class="line">           .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams)</span><br><span class="line">            .setTimeoutExpress(timeoutExpress)</span><br><span class="line">            .setNotifyUrl(PropertiesUtil.getProperty(<span class="string">"alipay.callback.url"</span>))<span class="comment">//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置</span></span><br><span class="line">            .setGoodsDetailList(goodsDetailList);</span><br><span class="line">   </span><br><span class="line">     <span class="comment">// 3. 初始化tradeService</span></span><br><span class="line">    tradeService = init_tradeService();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 当面付预下单</span></span><br><span class="line">    AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 根据下单返回结果进行后续处理</span></span><br><span class="line">    <span class="keyword">switch</span> (result.getTradeStatus()) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> SUCCESS:</span><br><span class="line">            logger.info(<span class="string">"支付宝预下单成功: )"</span>);</span><br><span class="line">    </span><br><span class="line">            <span class="comment">// 5.1 预下单成功，生成二维码到指定路径</span></span><br><span class="line">            trade_precreate_success(result, path);</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.createBySuccess(resultMap);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> FAILED:</span><br><span class="line">            logger.error(<span class="string">"支付宝预下单失败!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"支付宝预下单失败!!!"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">case</span> UNKNOWN:</span><br><span class="line">            logger.error(<span class="string">"系统异常，预下单状态未知!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"系统异常，预下单状态未知!!!"</span>);</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            logger.error(<span class="string">"不支持的交易状态，交易返回异常!!!"</span>);</span><br><span class="line">            <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"不支持的交易状态，交易返回异常!!!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title>Java执行机制</title>
    <url>/2020/03/04/java-execution-principle/</url>
    <content><![CDATA[<p>本文介绍了Java的动态编译机制</p>
<a id="more"></a>

<h2 id="Java执行机制"><a href="#Java执行机制" class="headerlink" title="Java执行机制"></a>Java执行机制</h2><p>首先，Java平台如今的主流版本（JDK8以上，HotSpot VM）中，主要采用混合模式进行代码执行。</p>
<p>Java主要使用<strong>JIT动态编译</strong>与<strong>解释器</strong>混合执行。</p>
<blockquote>
<p>JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。</p>
</blockquote>
<h3 id="JIT-编译过程"><a href="#JIT-编译过程" class="headerlink" title="JIT 编译过程"></a>JIT 编译过程</h3><p>当 JIT 编译启用时（默认是启用的），JVM 读入.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码。</p>
<p>具体来说，Java有热点代码编译功能，通过统计热点代码，将热点代码通过JIT编译成机器码交并存入Code Cache，而其余代码则由JVM解释执行。</p>
<p><img src="/2020/03/04/java-execution-principle/clipboard.png" alt="图片参考《码出高效》一书"></p>
<h3 id="Hot-Spot-编译"><a href="#Hot-Spot-编译" class="headerlink" title="Hot Spot 编译"></a>Hot Spot 编译</h3><p>当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因：</p>
<p>首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。</p>
<p>当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。</p>
<p>第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。</p>
<p>举一个简单的例子：我们知道<code> equals()</code>这个方法存在于每一个 Java Object 中而且经常被覆写。当解释器遇到<code>b = obj1.equals(obj2) </code>这样一句代码，它则会查询 obj1 的类型从而得知到底运行哪一个 <code>equals()</code> 方法。而这个动态查询的过程从某种程度上说是很耗时的。</p>
<h3 id="具体案例"><a href="#具体案例" class="headerlink" title="具体案例"></a>具体案例</h3><p>放到具体生产环境，这种执行方式造成了机器在热机状态可以承受的负载要大于冷机状态。</p>
<p>如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。</p>
<p><strong>案例：</strong></p>
<p>某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成两批发布，</p>
<p>如果是热机状态，正常情况下一半的机器可以勉强承载流量，但由于<strong>刚启动时的JVM均为解释执行，没有进行热点代码统计和JIT动态编译，</strong>导致当前1/2发布成功的服务器马上全部宕机。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>《码出高效——Java开发手册》</li>
<li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-just-in-time/index.html" target="_blank" rel="noopener">深入浅出 JIT 编译器</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>JIT</tag>
      </tags>
  </entry>
  <entry>
    <title>centOS下安装redis</title>
    <url>/2020/03/05/linux-install-redis/</url>
    <content><![CDATA[<p>CentOS6.8 安装redis过程记录</p>
<a id="more"></a>

<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1. 安装"></a>1. 安装</h2><blockquote>
<p>官网下载地址 <a href="https://redis.io/download" target="_blank" rel="noopener">https://redis.io/download</a></p>
</blockquote>
<p>linux下分别输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wget http://download.redis.io/releases/redis-5.0.3.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tar xzf redis-5.0.3.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> make install</span></span><br></pre></td></tr></table></figure>

<h2 id="2-编辑redis-conf配置文件"><a href="#2-编辑redis-conf配置文件" class="headerlink" title="2. 编辑redis.conf配置文件"></a>2. 编辑redis.conf配置文件</h2><p>由于redis默认在前台运行，我们希望它能够以守护进程的形式在后台运行，需要配置一下<code>redis.conf</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> redis-5.0.3</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> vim redis.conf</span></span><br></pre></td></tr></table></figure>

<p>找到daemonize，修改为yes，:wq保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">################################# GENERAL #####################################</span><br><span class="line"></span><br><span class="line"># By default Redis does not run as a daemon. Use &#39;yes&#39; if you need it.</span><br><span class="line"># Note that Redis will write a pid file in &#x2F;var&#x2F;run&#x2F;redis.pid when daemonized.</span><br><span class="line">daemonize yes</span><br></pre></td></tr></table></figure>

<h2 id="3-启动redis"><a href="#3-启动redis" class="headerlink" title="3. 启动redis"></a>3. 启动redis</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动并加载配置文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-server redis.conf</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动详情</span></span><br><span class="line">[lefter@shen redis-5.0.3]$ redis-server redis.conf</span><br><span class="line">8256:C 05 Mar 2019 14:40:56.851 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo</span><br><span class="line">8256:C 05 Mar 2019 14:40:56.851 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=8256, just started</span><br><span class="line">8256:C 05 Mar 2019 14:40:56.851 # Configuration loaded</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程</span></span><br><span class="line">[lefter@shen redis-5.0.3]$ ps aux | grep redis</span><br><span class="line">lefter     8257  0.6  0.4 152416  7804 ?        Ssl  14:40   0:00 redis-server 127.0.0.1:6379</span><br><span class="line">lefter     8262  0.0  0.0 103328   856 pts/0    S+   14:41   0:00 grep redis</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动redis命令行</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭redis</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> redis-cli shutdown</span></span><br></pre></td></tr></table></figure>

<h2 id="4-简化配置"><a href="#4-简化配置" class="headerlink" title="4.简化配置"></a>4.简化配置</h2><p>在<code>redis/utils</code>下，使用<code>install_server.sh</code>可以简化配置，并设置redis为开机启动</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lefter@shen utils]$ sudo ./install_server.sh </span><br><span class="line">Welcome to the redis service installer</span><br><span class="line">This script will help you easily set up a running redis server</span><br><span class="line"></span><br><span class="line">Please select the redis port for this instance: [6379] </span><br><span class="line">Selecting default: 6379</span><br><span class="line">Please select the redis config file name [/etc/redis/6379.conf] /usr/local/redis/redis.conf</span><br><span class="line">Please select the redis log file name [/var/log/redis_6379.log] /usr/local/redis/redis.log</span><br><span class="line">Please select the data directory for this instance [/var/lib/redis/6379] /usr/local/redis/data</span><br><span class="line">Please select the redis executable path [] /usr/local/bin/redis-server</span><br><span class="line">Selected config:</span><br><span class="line">Port           : 6379</span><br><span class="line">Config file    : /usr/local/redis/redis.conf</span><br><span class="line">Log file       : /usr/local/redis/redis.log</span><br><span class="line">Data dir       : /usr/local/redis/data</span><br><span class="line">Executable     : /usr/local/bin/redis-server</span><br><span class="line">Cli Executable : /usr/local/bin/redis-cli</span><br></pre></td></tr></table></figure>
<p>检查启动配置，已经变为开机启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[lefter@shen redis]$ chkconfig --list | grep redis</span><br><span class="line">redis_6379     	0:关闭	1:关闭	2:启用	3:启用	4:启用	5:启用	6:关闭</span><br></pre></td></tr></table></figure>
<p>可以通过service直接启动redis</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[lefter@shen redis]$ service redis_6379 status</span><br><span class="line">Redis is running (8105)</span><br><span class="line">[lefter@shen redis]$ service redis_6379 stop</span><br><span class="line">Stopping ...</span><br><span class="line">Redis stopped</span><br><span class="line">[lefter@shen redis]$ sudo service redis_6379 start</span><br><span class="line">Starting Redis server...</span><br></pre></td></tr></table></figure>

<h2 id="5-关于jedis访问的配置"><a href="#5-关于jedis访问的配置" class="headerlink" title="5. 关于jedis访问的配置"></a>5. 关于jedis访问的配置</h2><p>Redis默认配置只绑定了本地访问，<code>bind 127.0.0.1</code></p>
<p>由于我的Redis装在虚拟机中，需要在<code>redis.conf</code>中添加绑定虚拟机地址，如下：</p>
<p><code>bind 192.168.163.129</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">################################# NETWORK #####################################</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> By default, <span class="keyword">if</span> no <span class="string">"bind"</span> configuration directive is specified, Redis listens</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="keyword">for</span> connections from all the network interfaces available on the server.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> It is possible to listen to just one or multiple selected interfaces using</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the <span class="string">"bind"</span> configuration directive, followed by one or more IP addresses.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Examples:</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 192.168.1.100 10.0.0.1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">bind</span> 127.0.0.1 ::1</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> internet, binding to all the interfaces is dangerous and will expose the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> instance to everybody on the internet. So by default we uncomment the</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> following <span class="built_in">bind</span> directive, that will force Redis to listen only into</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> the IPv4 loopback interface address (this means Redis will be able to</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> accept connections only from clients running into the same computer it</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> is running).</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> JUST COMMENT THE FOLLOWING LINE.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span></span><br><span class="line">bind 127.0.0.1</span><br><span class="line">bind 192.168.163.129 # 在这里添加新的绑定</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>volatile关键字和synchronized关键字的区别</title>
    <url>/2020/02/27/volatile-and-synchronized/</url>
    <content><![CDATA[<p>本文介绍了volatile关键字和synchronized关键字的区别</p>
<a id="more"></a>

<p>一句话概括</p>
<p><strong>volatile保证了线程间的可见性和有序性</strong></p>
<p><strong>synchronized保证了线程间的原子性（同时保证了可见性和有序性）</strong></p>
<h3 id="Java内存模型"><a href="#Java内存模型" class="headerlink" title="Java内存模型"></a>Java内存模型</h3><p>首先，为了说明两者的区别，先要引出一个概念——<strong>Java内存模型(JMM)*<em>，该模型用于屏蔽各种硬件和操作系统带来的内存访问的差异，定义了程序中各个**</em>变量*</strong>（不包括局部变量和方法参数，因为这些是线程私有的）的访问规则。</p>
<p>JMM规定所有的变量都存储在<strong>主内存</strong>中，每条线程还有自己的<strong>工作内存</strong>，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成</p>
<p>需要注意的是，这里Java内存模型中的主内存，工作内存和Java内存区域中的Heap，Stack，方法区等是没有关系的，如果非要类比，主内存可以对应Heap中的对象实例的数据部分，工作内存对应JVM Stack中的部分区域。</p>
<h3 id="volatile语义"><a href="#volatile语义" class="headerlink" title="volatile语义"></a>volatile语义</h3><p><code>volatile</code>关键字可以说是Java虚拟机提供的最轻量级的同步机制。</p>
<p>当一个变量定义为<code>volatile</code>时，它将具备两种特性：</p>
<p>第一，保证此变量对所有线程的可见性。这里的可见性指的是当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量不能做到这一点，普通变量的值在线程间传递都需要通过主内存来完成。</p>
<p>第二，禁止指令重排序优化。</p>
<h3 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h3><p>如下图所示，有两个线程t1和t2，它们都需要使用对象A中的变量flag，这两个线程都会从主内存中copy一份对象A的变量flag，放到它们各自的线程工作内存中，然后在运行期间直接使用这份copy。</p>
<p>当t2线程需要修改flag的值，它会先把自己工作区的flag修改然后存入主内存中，但是t1并不会去访问heap中的flag，而是依旧使用自己工作区的copy。</p>
<p>当volatile关键字作用到变量flag上，将会强制所有线程都去主线程中读取变量flag的值。</p>
<p><img src="/2020/02/27/volatile-and-synchronized/clipboard-1551243763377.png" alt="img"></p>
<p>示例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 示例代码中有两个线程，主线程和main方法中启动的线程t1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*volatile*/</span> <span class="keyword">boolean</span> flag = <span class="keyword">true</span>; <span class="comment">//对比一下有无volatile的情况下，整个程序运行结果的区别</span></span><br><span class="line">	</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(<span class="string">"m start"</span>);</span><br><span class="line">		<span class="keyword">while</span>(flag) &#123;</span><br><span class="line">			</span><br><span class="line">		&#125;</span><br><span class="line">		System.out.println(<span class="string">"m end!"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        flag = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		T t = <span class="keyword">new</span> T();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">new</span> Thread(t::m, <span class="string">"t1"</span>).start();</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">// 主线程更改flag的值</span></span><br><span class="line">		shutdown();		</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上代码开启了一个线程t1，该线程执行m方法，如果不加<code>volatile</code>关键字，在主线程中更改flag的值，并不会使循环停止，这是由于t1线程执行时使用的是来自主线程的拷贝，并不会在执行时访问主线程，而<code>volatile</code>关键词使得主线程对flag的修改对于线程t1来说是可见的，t1会刷新flag的值并结束循环。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>由于<code>volatile</code>变量只能保证可见性，在不符合以下两条规则的场景中，我们仍需要通过加锁（使用<code>synchronized</code>或<code>java.util.concurrent</code>中的Atomic类）来保证原子性。</p>
<ul>
<li>运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值</li>
<li>变量不需要与其他的状态变量共同参与不变约束</li>
</ul>
<p>前面举的列子就很适合使用<code>volatile变量</code>来控制并发，当<code>shutdown()</code>被调用时，能保证所有线程中的m()方法立即停止。</p>
<p>大多数情况下使用<code>volatile</code>比<code>synchronized</code>开销低，选择的唯一依据就是我们是否在保证可见性和有序性的基础上，还需要保证原子性。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客SEO优化</title>
    <url>/2020/02/14/hexo-blog-seo-optimization/</url>
    <content><![CDATA[<p>文章介绍了Hexo搭建的博客的基本SEO优化，包括怎样提交到搜索引擎、站点地图的生成、网站统计、CDN加速、设置网站为HTTPS等内容</p>
<a id="more"></a>

<p>为了让我们的博客被搜索引擎爬取和收录，我们需要对博客进行SEO优化。</p>
<p><a href="https://zh.wikipedia.org/wiki/%E6%90%9C%E5%B0%8B%E5%BC%95%E6%93%8E%E6%9C%80%E4%BD%B3%E5%8C%96" target="_blank" rel="noopener"><strong>搜索引擎优化</strong></a>（英语：search engine optimization，缩写为SEO），是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。</p>
<h3 id="站点地图"><a href="#站点地图" class="headerlink" title="站点地图"></a>站点地图</h3><p><a href="https://zh.wikipedia.org/wiki/%E7%B6%B2%E7%AB%99%E5%9C%B0%E5%9C%96" target="_blank" rel="noopener">站点地图</a>描述了一个网站的架构 它可以是一个任意形式的文档，用作网页设计的设计工具，也可以是列出网站中所有页面的一个网页，通常采用分级形式。这有助于访问者以及搜索引擎的机器人找到网站中的页面。</p>
<ul>
<li>站点地图的作用<ul>
<li>为搜索引擎爬虫提供可以浏览整个网站的链接；</li>
<li>为搜索引擎爬虫提供一些链接，指向动态页面或者采用其他方法比较难以到达的页面；</li>
<li>如果访问者试图访问网站所在域内并不存在的URL，那么这个访问者就会被转到“无法找到文件”的错误页面，而网站地图可以作为该页面的“准”内容。</li>
</ul>
</li>
</ul>
<p>生成步骤：</p>
<ol>
<li>在hexo根目录下，运行以下指令安装站点地图生成的插件</li>
</ol>
<ul>
<li><p>Google </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
<li><p>Baidu </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-baidu-sitemap --save</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="2">
<li><p>插件安装完毕后，每次运行<code>hexo g</code>会自动生成站点地图，位置在<code>${hexo}\public</code>文件夹下。</p>
<p>Google和Baidu分别生成sitemap.xml，baidusitemap.xml</p>
<p>在hexo配置文件<code>_config.yml</code>中，添加如下配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">sitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">sitemap.xml</span></span><br><span class="line"><span class="attr">baidusitemap:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">baidusitemap.xml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>运行<code>hexo d</code>进行部署，然后在浏览器访问<code>你的域名/sitemap.xml</code>，如果看到xml文件，那么就说明站点地图部署成功了。</p>
</li>
</ol>
<h3 id="创建robots-txt"><a href="#创建robots-txt" class="headerlink" title="创建robots.txt"></a>创建robots.txt</h3><p><a href="https://zh.wikipedia.org/wiki/Robots.txt" target="_blank" rel="noopener">robots.txt</a>（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。具体实例可见<a href="https://zh.wikipedia.org/wiki/Robots.txt#%E4%BE%8B%E5%AD%90" target="_blank" rel="noopener">这里</a>。</p>
<p>在<code>${hexo根目录}\source</code>添加<code>robots.txt</code>，内容如下，可以根据需要自行修改拦截和允许通过等</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># hexo robots.txt</span><br><span class="line">User-agent: *</span><br><span class="line">Allow: &#x2F;</span><br><span class="line">Allow: &#x2F;archives&#x2F; </span><br><span class="line"></span><br><span class="line">Disallow: &#x2F;js&#x2F;</span><br><span class="line">Disallow: &#x2F;css&#x2F;</span><br><span class="line">Disallow: &#x2F;fonts&#x2F;</span><br><span class="line">Disallow: &#x2F;vendors&#x2F;</span><br><span class="line">Disallow: &#x2F;fancybox&#x2F;</span><br><span class="line"></span><br><span class="line">Sitemap: yourwebsiteurl&#x2F;sitemap.xml</span><br><span class="line">Sitemap: yourwebsiteurl&#x2F;baidusitemap.xml</span><br></pre></td></tr></table></figure>

<p>当运行<code>hexo d</code>部署后，该文件就会在网站的根目录下，搜索引擎就可以根据该文件进行爬取。</p>
<h3 id="数据统计与分析"><a href="#数据统计与分析" class="headerlink" title="数据统计与分析"></a>数据统计与分析</h3><p>使用搜索网站提供的数据分析服务可以直观的了解网站的各种运行数据，这里介绍两种常用的分析工具。</p>
<ul>
<li>Google Analysis</li>
</ul>
<ol>
<li>登录 <a href="https://analytics.google.com/analytics/web" target="_blank" rel="noopener">Google Analysis</a>，获得Google跟踪ID。</li>
<li>编辑 <strong>主题配置文件</strong>， 修改字段 <code>google_analytics</code>， 值设置成你的 Google 跟踪 ID。跟踪 ID 通常是以 <code>UA-</code> 开头。</li>
</ol>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550123640721.png" alt="1550123640721"></p>
<ul>
<li>百度统计</li>
</ul>
<ol>
<li>登录 <a href="http://tongji.baidu.com/" target="_blank" rel="noopener">百度统计</a>，定位到站点的代码获取页面</li>
<li>复制 <code>hm.js?</code> 后面那串统计脚本 id，如下图所示：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">var _hmt &#x3D; _hmt || [];</span><br><span class="line">(function() &#123;</span><br><span class="line">  var hm &#x3D; document.createElement(&quot;script&quot;);</span><br><span class="line">  hm.src &#x3D; &quot;https:&#x2F;&#x2F;hm.baidu.com&#x2F;hm.js?你的统计id&quot;;</span><br><span class="line">  var s &#x3D; document.getElementsByTagName(&quot;script&quot;)[0]; </span><br><span class="line">  s.parentNode.insertBefore(hm, s);</span><br><span class="line">&#125;)();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编辑 <strong>主题配置文件</strong>， 修改字段 <code>baidu_analytics</code>，值设置成你的百度统计脚本 id。</li>
</ol>
<h3 id="使用CloudFlare"><a href="#使用CloudFlare" class="headerlink" title="使用CloudFlare"></a>使用CloudFlare</h3><p>在百度进行HTTPS认证时，出现如下提示：</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550453191650.png" alt="1550453191650"></p>
<p>解决方法：在<a href="http://www.cloudflare.com中注册账号,根据官网提示进行相关配置/" target="_blank" rel="noopener">www.cloudflare.com中注册账号，根据官网提示进行相关配置</a></p>
<h4 id="1-更改域名服务商的Name-Servers"><a href="#1-更改域名服务商的Name-Servers" class="headerlink" title="1. 更改域名服务商的Name Servers"></a>1. 更改域名服务商的Name Servers</h4><p>将你的域名服务商的域名服务器改为cloudflare提供的两个，如下图</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550454986495.png" alt="1550454986495"></p>
<h4 id="2-page-rules设置"><a href="#2-page-rules设置" class="headerlink" title="2. page rules设置"></a>2. page rules设置</h4><p>等待域名服务商的域名服务器更新生效，dashboard的overview出现下图所示表示应用成功</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550455204080.png" alt="1550455204080"></p>
<p>然后在dashboard的page rules选项卡中进行如下配置</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550453144169.png" alt="1550453144169"></p>
<h4 id="3-HSTS设置"><a href="#3-HSTS设置" class="headerlink" title="3. HSTS设置"></a>3. HSTS设置</h4><blockquote>
<p>该段转自<a href="https://molunerfinn.com/hexo-travisci-https" target="_blank" rel="noopener">https://molunerfinn.com/hexo-travisci-https</a></p>
</blockquote>
<p>我们访问自己的网站是走HTTP-&gt;301/307重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。那有没有可能做到，访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作呢？答案是有的。通过HSTS的Preload List。</p>
<p>可以参考这篇文章对<a href="https://www.jianshu.com/p/caa80c7ad45c" target="_blank" rel="noopener">HSTS</a>进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。</p>
<p><code>CloudFare</code>自带HSTS功能，开启之后就能很好的满足我们的需要。</p>
<p>在<code>Crypto</code>选项下，开启<code>HSTS</code>，配置如下：</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550456001693.png" alt="1550456001693"></p>
<p>然后可以去<a href="https://hstspreload.org/" target="_blank" rel="noopener">HSTS Preload List</a>的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。网上的说法普遍是几周内。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就更加安全。</p>
<p>我在第一次提交时出现如下问题，大意是<code>http://wuleshen.com</code>需要直接定向到<code>https://wuleshen.com</code>,而现在是先定向到<code>https://www.wuleshen.com</code>这个子域</p>
<p><img src="/2020/02/14/hexo-blog-seo-optimization/1550457188872.png" alt="1550457188872"></p>
<p><a href="https://ws1.sinaimg.cn/large/8700af19gy1fi45hvxt3oj21fu0f8gn5.jpg" target="_blank" rel="noopener">HSTS Preload List</a></p>
<h3 id="配置-htaccess"><a href="#配置-htaccess" class="headerlink" title="配置 .htaccess"></a>配置 .htaccess</h3><p>概述来说，htaccess文件是<a href="https://baike.baidu.com/item/Apache" target="_blank" rel="noopener">Apache</a>服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页<a href="https://baike.baidu.com/item/301%E9%87%8D%E5%AE%9A%E5%90%91" target="_blank" rel="noopener">301重定向</a>、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。当然最多的还是rewrite功能，即URL重写，PHP中实现伪静态的一个重要途径，也是被公认为SEO中搜索引擎友好的极为有效的一个手段。</p>
<p>首先，在<code>${hexo根目录}\source</code>下生成.htaccess，可以用<code>touch .htaccess</code>命令</p>
<p>然后，可以通过<a href="http://htaccess.linuxnote.org/" target="_blank" rel="noopener">这个网站</a>进行快速生成.htaccess，将内容复制到.htaccess文件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Files ~ &quot;^.(htaccess|htpasswd)$&quot;&gt;</span><br><span class="line">deny from all</span><br><span class="line">&lt;&#x2F;Files&gt;</span><br><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond %&#123;HTTP_HOST&#125; ^(www\.wuleshen\.com)(:80)? [NC]</span><br><span class="line">RewriteRule ^(.*) https:&#x2F;&#x2F;wuleshen.com&#x2F;$1 [R&#x3D;301,L]</span><br><span class="line">Redirect permanent http:&#x2F;&#x2F;wuleshen.com https:&#x2F;&#x2F;wuleshen.com</span><br><span class="line">order deny,allow</span><br></pre></td></tr></table></figure>

<p>此外，要让该文件生效，需要在hexo配置文件<code>_config.yml</code>中添加以下内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">include:</span><br><span class="line">  - .htaccess</span><br></pre></td></tr></table></figure>

<p>最后，<code>hexo d</code>将文件部署。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://theme-next.iissnan.com/third-party-services.html#analytics-system" target="_blank" rel="noopener">https://theme-next.iissnan.com/third-party-services.html#analytics-system</a></li>
<li><a href="https://molunerfinn.com/hexo-travisci-https" target="_blank" rel="noopener">https://molunerfinn.com/hexo-travisci-https</a></li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title>linux软件安装手册</title>
    <url>/2020/03/07/install-under-linux/</url>
    <content><![CDATA[<p>本文记录了在linux CentOS6.8系统下，各种软件的安装配置过程，以供今后参考查阅。</p>
<a id="more"></a>

<p>打算把之前做的练手项目发布在线上，在阿里云申请了一台服务器，申请过程这里先略过了，今后有时间在写。</p>
<p>为了更熟悉linux系统以及linux命令，我申请的是空白的系统，里面没有安装任何软件，需要手动配置安装，这里记录了安装过程，以供将来查阅。</p>
<p>最终，由于阿里云的备案条件变更，新开的服务器在3个月内不能备案，导致项目最终上线失败，不过用ip直接访问服务器并测试了一部分功能是可以用的。等备案通过后，将再次进行上线测试。</p>
<h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><ol>
<li>从官网下载jdk1.8</li>
</ol>
<p><a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html</a></p>
<p>将安装包<strong>jdk-8u201-linux-x64.rpm</strong>复制到/opt/目录下, 可以通过xftp软件</p>
<ol start="2">
<li>安装rpm包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rpm -ivh jdk-8u201-linux-x64.rpm</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>配置环境变量</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/profile</span></span><br></pre></td></tr></table></figure>

<p>在文档末尾添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_201-amd64</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>保存退出后执行,验证<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">source</span> /etc/profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> java -version</span></span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z ~]$ java -version</span><br><span class="line">java version "1.8.0_201"</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_201-b09)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.201-b09, mixed mode)</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h2><ol>
<li>从官网下载tomcat8.5.38</li>
</ol>
<p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener">https://tomcat.apache.org/download-80.cgi</a></p>
<p>将安装包<strong>apache-tomcat-8.5.38.tar.gz</strong>放到/opt/目录下</p>
<ol start="2">
<li>解压安装包</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf apache-tomcat-8.5.38.tar.gz</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>编辑server.xml</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /opt/apache-tomcat-8.5.38/conf/server.xml</span></span><br></pre></td></tr></table></figure>
<p>添加URIEncoding,解决乱码问题</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;Connector port&#x3D;&quot;8080&quot; protocol&#x3D;&quot;HTTP&#x2F;1.1&quot;</span><br><span class="line">               connectionTimeout&#x3D;&quot;20000&quot;</span><br><span class="line">               redirectPort&#x3D;&quot;8443&quot; URIEncoding&#x3D;&quot;UTF-8&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>开启防火墙</li>
</ol>
<p>阿里云通过添加安全组规则开放8080端口</p>
<p>也可以手动开启防火墙, </p>
<blockquote>
<p>在centos6.8中，防火墙在iptables中配置，centos7以上版本通过firewall配置</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/iptables</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">-A INPUT -p tcp -m tcp --dport 8080 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启防火墙</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service iptables restart</span></span><br></pre></td></tr></table></figure>


<ol start="5">
<li>启动tomcat</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/apache-tomcat-8.5.38/bin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./startup.sh</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li>外接访问测试</li>
</ol>
<ul>
<li>浏览器中输入<code>阿里云公网ip:8080</code>访问tomcat<h2 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h2></li>
</ul>
<ol>
<li>从官网下载maven</li>
</ol>
<p><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">https://maven.apache.org/download.cgi</a></p>
<p>将安装包<strong>apache-maven-3.6.0-bin.tar.gz</strong>复制到/opt/目录下</p>
<ol start="2">
<li><p>解压安装包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf apache-maven-3.6.0-bin.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置环境变量</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/profile</span></span><br></pre></td></tr></table></figure>
<p>在profile中添加</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export JAVA_HOME=/usr/java/jdk1.8.0_181-amd64</span><br><span class="line">export MAVEN_HOME=/opt/apache-maven-3.6.0</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/jre/lib/rt.jar:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$JAVA_HOME/bin:$MAVEN_HOME/bin:$PATH</span><br></pre></td></tr></table></figure>
</li>
<li><p>保存退出后执行,验证</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo <span class="built_in">source</span> /etc/profile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mvn -version</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z java]$ mvn -v</span><br><span class="line">Apache Maven 3.6.0 (97c98ec64a1fdfee7767ce5ffb20918da4f719f3; 2018-10-25T02:41:47+08:00)</span><br><span class="line">Maven home: /developer/apache-maven-3.6.0</span><br><span class="line">Java version: 1.8.0_201, vendor: Oracle Corporation, runtime: /usr/java/jdk1.8.0_201-amd64/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: "linux", version: "2.6.32-696.6.3.el6.x86_64", arch: "amd64", family: "unix"</span><br></pre></td></tr></table></figure>

<h2 id="安装Nginx"><a href="#安装Nginx" class="headerlink" title="安装Nginx"></a>安装Nginx</h2><h3 id="Nginx是什么"><a href="#Nginx是什么" class="headerlink" title="Nginx是什么"></a>Nginx是什么</h3><p>Nginx是一款轻量级<strong>web服务器</strong>，也是一款<strong>反向代理服务器</strong></p>
<p><strong>用途</strong></p>
<ul>
<li>直接支持rails和PHP的程序</li>
<li>HTTP反向代理服务器</li>
<li>负载均衡服务器</li>
<li>邮件代理服务器</li>
<li>帮助实现前端动静分离</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>高稳定</li>
<li>高性能</li>
<li>资源占用少</li>
<li>功能丰富</li>
<li>模块化结构</li>
<li>支持热部署</li>
</ul>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><ol>
<li>安装gcc</li>
<li>安装pcre</li>
<li>安装zlib</li>
<li>安装openssl</li>
</ol>
<ul>
<li>综合安装以上4个依赖<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ yum -y install gcc pcre-devel zlib zlib-devel openssl openssl-devel</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="5">
<li>下载源码包</li>
</ol>
<p>在官网选择稳定版本下载</p>
<p><a href="https://nginx.org/en/download.html" target="_blank" rel="noopener">https://nginx.org/en/download.html</a> </p>
<ul>
<li>源码包下载至/opt/,并解压缩<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf nginx-1.14.2.tar.gz</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li>Nginx安装</li>
</ol>
<ul>
<li>进入nginx目录后执行./configure<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> nginx-1.14.2/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo ./configure</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make install</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询Nginx安装位置，默认安装在/usr/<span class="built_in">local</span>/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> whereis nginx</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入nginx安装位置，找到sbin/,执行./nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> sbin/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./nginx</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看是否开启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps aux | grep nginx</span></span><br><span class="line"></span><br><span class="line">root       8238  0.0  0.0  23968   820 ?        Ss   21:04   0:00 nginx: master process ./nginx</span><br><span class="line">nobody     8239  0.0  0.0  24388  1400 ?        S    21:04   0:00 nginx: worker process</span><br><span class="line">root       8248  0.0  0.0 103328   860 pts/2    S+   21:04   0:00 grep nginx</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="7">
<li><p>增加防火墙访问权限</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/iptables</span></span><br></pre></td></tr></table></figure>
<p>增加以下内容, 开启80端口</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">-A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT</span><br></pre></td></tr></table></figure>
<p>保存退出，重启防火墙</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service iptables restart</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>验证</p>
</li>
</ol>
<p>浏览器中输入公网的ip，显示nginx页面</p>
<hr>
<h3 id="Nginx常用命令"><a href="#Nginx常用命令" class="headerlink" title="Nginx常用命令"></a>Nginx常用命令</h3><ul>
<li>测试配置文件</li>
</ul>
<p>安装路径下的 <code>/nginx/sbin/nginx -t</code></p>
<ul>
<li>启动命令</li>
</ul>
<p>安装路径下的<code> /nginx/sbin/nginx</code></p>
<ul>
<li><p>停止命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装路径下的 &#x2F;nginx&#x2F;sbin&#x2F;nginx -s stop</span><br><span class="line">或者是 nginx -s quit</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启命令</p>
</li>
</ul>
<p>安装路径下的<code> /nginx/sbin/nginx -s reload</code></p>
<ul>
<li>查看进程命令</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ps -ef | grep nginx</span><br></pre></td></tr></table></figure>

<ul>
<li>平滑重启</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kill -HUP [Nginx主进程号（即查看命令查看到的PID）]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Nginx虚拟域名配置及测试验证"><a href="#Nginx虚拟域名配置及测试验证" class="headerlink" title="Nginx虚拟域名配置及测试验证"></a>Nginx虚拟域名配置及测试验证</h3><ol>
<li>编辑nginx.conf<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo vim &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;nginx.conf</span><br></pre></td></tr></table></figure>
找到<code>another virtual host using mix of IP-, </code></li>
</ol>
<p>增加 <code>include vhost/*.conf; </code>，保存并退出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">##########################vhost#####################################</span><br><span class="line">    include vhost&#x2F;*.conf;</span><br><span class="line"></span><br><span class="line">    # another virtual host using mix of IP-, name-, and port-based configuration</span><br><span class="line">    #</span><br><span class="line">    #server &#123;</span><br><span class="line">    #    listen       8000;</span><br><span class="line">    #    listen       somename:8080;</span><br></pre></td></tr></table></figure>

<ul>
<li>配置域名转发</li>
</ul>
<p>首先配置host文件，设置完成后重启浏览器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;hosts</span><br><span class="line"># 添加对应的域名及ip</span><br><span class="line">本机ip www.wuleshen.top</span><br><span class="line"># 保存退出</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建域名转发配置文件</li>
</ol>
<p>在/usr/local/nginx/conf目录新建vhost文件夹</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf</span><br><span class="line">$ mkdir vhost</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>创建域名转发配置文件</li>
</ol>
<ul>
<li><a href="http://www.wuleshe.top/" target="_blank" rel="noopener">www.wuleshe.top</a></li>
</ul>
<p>将网址映射到本地的8080端口，即tomcat</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd vhost</span><br><span class="line">$ sudo vim www.wuleshen.top.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 添加以下内容</span><br><span class="line">server &#123;</span><br><span class="line">    default_type &#39;text&#x2F;html&#39;;</span><br><span class="line">    charset utf-8;</span><br><span class="line">    listen 80;</span><br><span class="line">    autoindex on;</span><br><span class="line">    server_name www.wuleshen.top;</span><br><span class="line">    access_log &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;logs&#x2F;access.log combined;</span><br><span class="line">    index index.html index.htm index.jsp index.php;</span><br><span class="line">    #error_page 404 &#x2F;404.html;</span><br><span class="line">    if ( $query_string ~* &quot;.*[\;&#39;\&lt;\&gt;].*&quot; )&#123;</span><br><span class="line">        return 404;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    location &#x2F; &#123;</span><br><span class="line">        proxy_pass http:&#x2F;&#x2F;127.0.0.1:8080;</span><br><span class="line">        add_header Access-Control-Allow-Origin *;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>启动（重启）验证</li>
</ol>
<ul>
<li><p>启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ $&#123;nginx&#125;&#x2F;sbin&#x2F;nginx</span><br></pre></td></tr></table></figure>
</li>
<li><p>重启</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ $&#123;nginx&#125;&#x2F;sbin&#x2F;nginx -s reload</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>${nginx}代表在系统中安装的路径，例如/usr/local/nginx</p>
<ol start="5">
<li>访问验证</li>
</ol>
<p><a href="http://localhost/" target="_blank" rel="noopener">http://localhost:80</a></p>
<h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><ol>
<li>从官网获得yum库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">检查是否已安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo rpm -qa | grep mysql-server</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo wget https://dev.mysql.com/get/mysql80-community-release-el6-2.noarch.rpm</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装yum包</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo rpm -Uvh mysql80-community-release-el6-2.noarch.rpm</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> yum repolist all | grep mysql</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果安装5.7旧版本可以配置如下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">disable</span> mysql80-community</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum-config-manager --<span class="built_in">enable</span> mysql57-community</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果yum-config-manager命令找不到，需要安装yum工具</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum -y install yum-utils</span></span><br></pre></td></tr></table></figure>
<p>再次查询<code>yum repolist all | grep mysql</code>, 查询到需要的版本已经enabled</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z src]$ yum repolist all | grep mysql</span><br><span class="line">mysql-cluster-7.5-community        MySQL Cluster 7.5 Community   disabled</span><br><span class="line">mysql-cluster-7.5-community-source MySQL Cluster 7.5 Community - disabled</span><br><span class="line">mysql-cluster-7.6-community        MySQL Cluster 7.6 Community   disabled</span><br><span class="line">mysql-cluster-7.6-community-source MySQL Cluster 7.6 Community - disabled</span><br><span class="line">mysql-connectors-community         MySQL Connectors Community    enabled:     83</span><br><span class="line">mysql-connectors-community-source  MySQL Connectors Community -  disabled</span><br><span class="line">mysql-tools-community              MySQL Tools Community         enabled:     74</span><br><span class="line">mysql-tools-community-source       MySQL Tools Community - Sourc disabled</span><br><span class="line">mysql-tools-preview                MySQL Tools Preview           disabled</span><br><span class="line">mysql-tools-preview-source         MySQL Tools Preview - Source  disabled</span><br><span class="line">mysql55-community                  MySQL 5.5 Community Server    disabled</span><br><span class="line">mysql55-community-source           MySQL 5.5 Community Server -  disabled</span><br><span class="line">mysql56-community                  MySQL 5.6 Community Server    disabled</span><br><span class="line">mysql56-community-source           MySQL 5.6 Community Server -  disabled</span><br><span class="line">mysql57-community                  MySQL 5.7 Community Server    enabled:    309</span><br><span class="line">mysql57-community-source           MySQL 5.7 Community Server -  disabled</span><br><span class="line">mysql80-community                  MySQL 8.0 Community Server    disabled</span><br><span class="line">mysql80-community-source           MySQL 8.0 Community Server -  disabled</span><br></pre></td></tr></table></figure>
</li>
<li><p>安装mySql</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum install mysql-community-server</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<p>默认配置文件路径：</p>
<ul>
<li>配置文件：/etc/my.cnf</li>
<li>日志文件：/var/log/var/log/mysqld.log</li>
<li>服务启动脚本：/usr/lib/systemd/system/mysqld.service</li>
<li>socket文件：/var/run/mysqld/mysqld.pid</li>
</ul>
<ol start="4">
<li>字符集配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim /etc/my.cnf</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在[mysqld]节点下添加</span></span><br><span class="line">character-set-server=utf8mb4</span><br><span class="line"><span class="meta">#</span><span class="bash"> 保存退出</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>自启动配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chkconfig mysqld on</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果2-5位为on即可</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> chkconfig --list mysqld</span></span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z etc]$ sudo chkconfig --list mysqld</span><br><span class="line">mysqld         	0:off	1:off	2:on	3:on	4:on	5:on	6:off</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>防火墙配置</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/iptables</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">-A INPUT -p tcp -m tcp --dport 3306 -j ACCEPT</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo service iptables restart</span></span><br></pre></td></tr></table></figure>

<ol start="7">
<li>启动mysql<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service mysqld start</span></span><br></pre></td></tr></table></figure>
<h2 id="安装FTP工具"><a href="#安装FTP工具" class="headerlink" title="安装FTP工具"></a>安装FTP工具</h2></li>
</ol>
<p>选择vsftpd作为ftp工具</p>
<ol>
<li><p>yum安装</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo yum remove vsftpd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo yum -y install vsftpd</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ftpfile文件<br> 此文件夹用于接受ftp上传的文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由用户选择装在哪里</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo mkdir ftpfile</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> ftpfile/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建ftpfile用户</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">//在指定目录下创建用户，并且设定不能登录</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo useradd ftpuser -d /ftpfile/ -s /sbin/nologin</span></span><br><span class="line">//将/ftpfile/的用户设置成ftpuser组的ftpuser用户</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo chown -R ftpuser.ftpuser /ftpfile/</span></span><br><span class="line">//设置用户密码</span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo passwd ftpuser</span></span><br></pre></td></tr></table></figure>
<p>在这里创建一个index.html文件，内容随便写</p>
</li>
<li><p>配置vsftpd</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/vsftpd/vsftpd.conf</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><p>查找banner，修改成如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> You may fully customise the login banner string:</span></span><br><span class="line">ftpd_banner=Welcome to my FTP service.</span><br><span class="line"></span><br><span class="line">local_root=/ftpfile</span><br><span class="line">anon_root=/ftpfile</span><br><span class="line"></span><br><span class="line">use_localtime=YES</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找chroot_list节点，修改成如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chroot_list_enable=YES</span><br><span class="line"><span class="meta">#</span><span class="bash"> (default follows)</span></span><br><span class="line">chroot_list_file=/etc/vsftpd/chroot_list</span><br></pre></td></tr></table></figure></li>
<li><p>查找anonymous_enable,修改为如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Allow anonymous FTP? (Beware - allowed by default <span class="keyword">if</span> you comment this out).</span></span><br><span class="line">anonymous_enable=NO</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="5">
<li>创建chroot_list<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /etc/vsftpd</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo vim chroot_list</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在chroot_list中添加ftpuser<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ftpuser</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="6">
<li><p>重启vsftpd服务</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service vsftpd restart</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>使用PASV工作模式</p>
</li>
</ol>
<ul>
<li>在设置/etc/vsftpd/vsftpd.conf中设置端口范围，为了让防火墙的设置可以更严格<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pasv_enable=YES</span><br><span class="line">pasv_min_port=61001</span><br><span class="line">pasv_max_port=62000</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="8">
<li>设置防火墙iptables<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo vim /etc/sysconfig/iptables</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>在配置中添加<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> vsftpd</span></span><br><span class="line">-A INPUT -p TCP --dport 61001:62000 -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --sport 61001:62000 -j ACCEPT</span><br><span class="line"></span><br><span class="line">-A INPUT -p TCP --dport 20 -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --dport 20 -j ACCEPT</span><br><span class="line">-A INPUT -p TCP --dport 21 -j ACCEPT</span><br><span class="line">-A OUTPUT -p TCP --dport 21 -j ACCEPT</span><br></pre></td></tr></table></figure></li>
<li>重启防火墙<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo service vsftpd restart</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ol start="9">
<li>验证</li>
</ol>
<ul>
<li>在浏览器中输入公网的ip地址<code>ftp://ip地址</code>，分别输入ftpuser用户名和密码登录</li>
<li>在bash命令行输入<code>ftp ip地址</code>，分别输入ftpuser用户名和密码，dir查看ftp文件夹</li>
</ul>
<h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><ol>
<li>下载安装包</li>
</ol>
<blockquote>
<p><a href="https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz" target="_blank" rel="noopener">https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz</a></p>
</blockquote>
<p>或者</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /opt/</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo wget https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.9.5.tar.gz</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>安装依赖</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y curl-devel expat-devel gettext-devel openssl-devel zlib-devel perl-ExtUtils-MakeMaker perl-ExtUtils-CBuilder cpio</span><br></pre></td></tr></table></figure>
</li>
<li><p>解压安装包并编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo tar -zxvf v2.9.5.tar.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> git-2.9.5</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译安装到/usr/<span class="built_in">local</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make prefix=/usr/<span class="built_in">local</span> all</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo make prefix=/usr/<span class="built_in">local</span> install</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>检验</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git --version</span></span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z git-2.9.5]$ git --version</span><br><span class="line">git version 2.9.5</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置git config</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">"ShawnWu"</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">"wuleshen@163.com"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略系统换行符转换</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.autocrlf <span class="literal">false</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global core.quotepath off</span></span><br></pre></td></tr></table></figure>

<ol start="6">
<li><p>配置秘钥</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z git-2.9.5]$ ssh-keygen -t rsa -C "wuleshen@163.com"</span><br><span class="line">Generating public/private rsa key pair.</span><br><span class="line">Enter file in which to save the key (/usr/shawn/.ssh/id_rsa): </span><br><span class="line">Created directory '/usr/shawn/.ssh'.</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in /usr/shawn/.ssh/id_rsa.</span><br><span class="line">Your public key has been saved in /usr/shawn/.ssh/id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">4e:df:d2:1a:b0:73:e5:47:d1:a9:2f:03:93:f1:37:9a wuleshen@163.com</span><br><span class="line">The key's randomart image is:</span><br><span class="line">+--[ RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|               ..|</span><br><span class="line">|           .  ...|</span><br><span class="line">|            + .. |</span><br><span class="line">|        S  +.o.o |</span><br><span class="line">|       o + =o.= .|</span><br><span class="line">|        + = +E.. |</span><br><span class="line">|         o + .o  |</span><br><span class="line">|          .      |</span><br><span class="line">+-----------------+</span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z git-2.9.5]$ ssh-add ~/.ssh/id_rda</span><br><span class="line">Could not open a connection to your authentication agent.</span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z git-2.9.5]$ eval `ssh-agent`</span><br><span class="line">Agent pid 5303</span><br><span class="line"></span><br><span class="line">[shawn@iZuf6g1m7s7snog7015pz9Z git-2.9.5]$ ssh-add ~/.ssh/id_rsa</span><br><span class="line">Identity added: /usr/shawn/.ssh/id_rsa (/usr/shawn/.ssh/id_rsa)</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看RSA公钥</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat ~/.ssh/id_rsa.pub</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>将公钥添加到github</p>
</li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>手册</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对接支付宝支付功能（一）官方Demo调试</title>
    <url>/2020/01/22/java-alipay-1/</url>
    <content><![CDATA[<p>支付宝当面付功能官方Demo调试的相关内容</p>
<a id="more"></a>

<h3 id="支付宝当面付官方Demo调试"><a href="#支付宝当面付官方Demo调试" class="headerlink" title="支付宝当面付官方Demo调试"></a>支付宝当面付官方Demo调试</h3><h4 id="配置沙箱环境"><a href="#配置沙箱环境" class="headerlink" title="配置沙箱环境"></a>配置沙箱环境</h4><p><a href="https://docs.open.alipay.com/200/105311" target="_blank" rel="noopener"><strong>官方文档</strong></a></p>
<p>点击“开放平台-开发者中心-<a href="https://openhome.alipay.com/platform/appDaily.htm" target="_blank" rel="noopener">沙箱环境</a>”。进入沙箱环境页面，系统已经自动为你创建一个应用，在基础信息中可以看到应用信息。</p>
<ol>
<li><p>生成并上传RSA2(SHA256)的应用公钥，详见<a href="https://docs.open.alipay.com/291/105971" target="_blank" rel="noopener">生成RSA密钥</a>；配置RSA2(SHA256)的应用公钥后，不需要配置RSA(SHA1)密钥，<a href="https://docs.open.alipay.com/291/106115" target="_blank" rel="noopener">RSA和RSA2签名算法区别可以参考此处</a>；</p>
</li>
<li><p>编写代码时，请将</p>
</li>
</ol>
<p>​          a.请求网关修改为：<a href="https://openapi.alipaydev.com/gateway.do" target="_blank" rel="noopener">https://openapi.alipaydev.com/gateway.do</a></p>
<p>​          b.appid切换为沙箱的appid</p>
<p>​          c.签名方式使用RSA2</p>
<p>​          d.应用私钥使用第1步生成的RSA2(SHA256)的私钥(请根据开发语言进行选择原始或pkcs8格式)</p>
<p>​          e.支付宝公钥切换为第1步配置后应用公钥后，点击查看支付宝公钥看到的公钥</p>
<h4 id="当面付demo演示"><a href="#当面付demo演示" class="headerlink" title="当面付demo演示"></a>当面付demo演示</h4><ol>
<li><p>下载demo，地址：<a href="https://docs.open.alipay.com/194/105201/" target="_blank" rel="noopener">https://docs.open.alipay.com/194/105201/</a></p>
</li>
<li><p>将demo导入idea</p>
</li>
<li><p>配置支付相关的属性alipayinfo.properties</p>
</li>
</ol>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 支付宝网关名、partnerId和appId</span></span><br><span class="line"><span class="attr">open_api_domain</span> = <span class="string">https://openapi.alipaydev.com/gateway.do</span></span><br><span class="line"><span class="attr">mcloud_api_domain</span> = <span class="string">http://mcloudmonitor.com/gateway.do</span></span><br><span class="line"><span class="attr">pid</span> = <span class="string">你的pid</span></span><br><span class="line"><span class="attr">appid</span> = <span class="string">你的appid</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RSA秘钥生成具体见官方文档</span></span><br><span class="line"><span class="comment"># 应用私钥公钥</span></span><br><span class="line"><span class="attr">private_key</span> = <span class="string">应用公钥</span></span><br><span class="line"><span class="attr">public_key</span> =  <span class="string">应用私钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SHA1withRsa对应支付宝公钥</span></span><br><span class="line"><span class="comment">#alipay_public_key = 使用RSA2时，不用配置此项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#SHA256withRsa对应支付宝公钥</span></span><br><span class="line"><span class="attr">alipay_public_key</span> = <span class="string">支付宝公钥</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsa</span></span><br><span class="line"><span class="attr">sign_type</span> = <span class="string">RSA2</span></span><br><span class="line"><span class="comment"># 当面付最大查询次数和查询间隔（毫秒）</span></span><br><span class="line"><span class="attr">max_query_retry</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">query_duration</span> = <span class="string">5000</span></span><br><span class="line"><span class="comment"># 当面付最大撤销次数和撤销间隔（毫秒）</span></span><br><span class="line"><span class="attr">max_cancel_retry</span> = <span class="string">3</span></span><br><span class="line"><span class="attr">cancel_duration</span> = <span class="string">2000</span></span><br><span class="line"><span class="comment"># 交易保障线程第一次调度延迟和调度间隔（秒）</span></span><br><span class="line"><span class="attr">heartbeat_delay</span> = <span class="string">5</span></span><br><span class="line"><span class="attr">heartbeat_duration</span> = <span class="string">900</span></span><br></pre></td></tr></table></figure>



<ol start="4">
<li>启动main方法</li>
</ol>
<p>运行结果</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">54</span> 下午 com.alipay.demo.trade.config.Configs init</span><br><span class="line">信息: 配置文件名: alipayinfo.properties</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">54</span> 下午 com.alipay.demo.trade.config.Configs init</span><br><span class="line">信息: Configs&#123;支付宝openapi网关: https:<span class="comment">//openapi.alipaydev.com/gateway.do</span></span><br><span class="line">, 支付宝mcloudapi网关域名: http:<span class="comment">//mcloudmonitor.com/gateway.do</span></span><br><span class="line">, pid: <span class="number">2088102177123264</span></span><br><span class="line">, appid: <span class="number">2016092400588794</span></span><br><span class="line">, 商户RSA私钥: MIIEvg******g1jt2A</span><br><span class="line">, 商户RSA公钥: MIIBIj******IDAQAB</span><br><span class="line">, 支付宝RSA公钥: MIIBIj******IDAQAB</span><br><span class="line">, 签名类型: RSA2</span><br><span class="line">, 查询重试次数: <span class="number">5</span></span><br><span class="line">, 查询间隔(毫秒): <span class="number">5000</span></span><br><span class="line">, 撤销尝试次数: <span class="number">3</span></span><br><span class="line">, 撤销重试间隔(毫秒): <span class="number">2000</span></span><br><span class="line">, 交易保障调度延迟(秒): <span class="number">5</span></span><br><span class="line">, 交易保障调度间隔(秒): <span class="number">900</span></span><br><span class="line">&#125;</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">54</span> 下午 com.alipay.demo.trade.service.impl.AbsAlipayTradeService tradePrecreate</span><br><span class="line">信息: trade.precreate bizContent:&#123;<span class="string">"out_trade_no"</span>:<span class="string">"tradeprecreate15481691348134324306"</span>,<span class="string">"seller_id"</span>:<span class="string">""</span>,<span class="string">"total_amount"</span>:<span class="string">"0.01"</span>,<span class="string">"undiscountable_amount"</span>:<span class="string">"0"</span>,<span class="string">"subject"</span>:<span class="string">"xxx品牌xxx门店当面付扫码消费"</span>,<span class="string">"body"</span>:<span class="string">"购买商品3件共20.00元"</span>,<span class="string">"goods_detail"</span>:[&#123;<span class="string">"goods_id"</span>:<span class="string">"goods_id001"</span>,<span class="string">"goods_name"</span>:<span class="string">"xxx小面包"</span>,<span class="string">"quantity"</span>:<span class="number">1</span>,<span class="string">"price"</span>:<span class="string">"10"</span>&#125;,&#123;<span class="string">"goods_id"</span>:<span class="string">"goods_id002"</span>,<span class="string">"goods_name"</span>:<span class="string">"xxx牙刷"</span>,<span class="string">"quantity"</span>:<span class="number">2</span>,<span class="string">"price"</span>:<span class="string">"5"</span>&#125;],<span class="string">"operator_id"</span>:<span class="string">"test_operator_id"</span>,<span class="string">"store_id"</span>:<span class="string">"test_store_id"</span>,<span class="string">"extend_params"</span>:&#123;<span class="string">"sys_service_provider_id"</span>:<span class="string">"2088100200300400500"</span>&#125;,<span class="string">"timeout_express"</span>:<span class="string">"120m"</span>&#125;</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.api.internal.util.AlipayLogger logBizSummary</span><br><span class="line">信息: Summary^_^<span class="number">10000</span>^_^<span class="keyword">null</span>^_^ProtocalMustParams:charset=utf-<span class="number">8</span>&amp;method=alipay.trade.precreate&amp;sign=eT6bgbDSF33TeESmRaqWCzfKZ5FB23e4ul6IOdPR9y1Lk6fKEWAhIWW/H0PWt4ttzsyhazy/HnoP4rSNBA11MW6FkK7EA7bwvU+V/kuDEMer4mbq9bPZ44zq5XHUW2wWxrGEIXWGa0O2UwFg1ahWDJCeXGUYqndOFtgMLeuKsShEZ7l/<span class="number">6</span>t9xfMEQSUyfzutucqgGGBApA3YNRpxa7Dh0zD1PZw0yqe0qDpEp2mbNvOEYWilaLS1wtHwOaOzNYKXJ+<span class="number">9</span>xfrz1YMjh6R0ikbIRGdKxPuTLiRB7F8pLim/QwvZYC/n0O9tmIF1X7CrN44Vimhy23IY3VEWbjuGKD4jvM8Q==&amp;version=<span class="number">1.0</span>&amp;app_id=<span class="number">2016092400588794</span>&amp;sign_type=RSA2&amp;timestamp=<span class="number">2019</span>-<span class="number">01</span>-<span class="number">22</span> <span class="number">22</span>:<span class="number">58</span>:<span class="number">54</span>^_^ProtocalOptParams:alipay_sdk=alipay-sdk-java-<span class="number">3.3</span><span class="number">.0</span>&amp;format=json^_^ApplicationParams:biz_content=&#123;<span class="string">"out_trade_no"</span>:<span class="string">"tradeprecreate15481691348134324306"</span>,<span class="string">"seller_id"</span>:<span class="string">""</span>,<span class="string">"total_amount"</span>:<span class="string">"0.01"</span>,<span class="string">"undiscountable_amount"</span>:<span class="string">"0"</span>,<span class="string">"subject"</span>:<span class="string">"xxx品牌xxx门店当面付扫码消费"</span>,<span class="string">"body"</span>:<span class="string">"购买商品3件共20.00元"</span>,<span class="string">"goods_detail"</span>:[&#123;<span class="string">"goods_id"</span>:<span class="string">"goods_id001"</span>,<span class="string">"goods_name"</span>:<span class="string">"xxx小面包"</span>,<span class="string">"quantity"</span>:<span class="number">1</span>,<span class="string">"price"</span>:<span class="string">"10"</span>&#125;,&#123;<span class="string">"goods_id"</span>:<span class="string">"goods_id002"</span>,<span class="string">"goods_name"</span>:<span class="string">"xxx牙刷"</span>,<span class="string">"quantity"</span>:<span class="number">2</span>,<span class="string">"price"</span>:<span class="string">"5"</span>&#125;],<span class="string">"operator_id"</span>:<span class="string">"test_operator_id"</span>,<span class="string">"store_id"</span>:<span class="string">"test_store_id"</span>,<span class="string">"extend_params"</span>:&#123;<span class="string">"sys_service_provider_id"</span>:<span class="string">"2088100200300400500"</span>&#125;,<span class="string">"timeout_express"</span>:<span class="string">"120m"</span>&#125;^_^<span class="number">567</span>ms,<span class="number">524</span>ms,<span class="number">22</span>ms</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.demo.trade.service.impl.AbsAlipayService getResponse</span><br><span class="line">信息: &#123;<span class="string">"alipay_trade_precreate_response"</span>:&#123;<span class="string">"code"</span>:<span class="string">"10000"</span>,<span class="string">"msg"</span>:<span class="string">"Success"</span>,<span class="string">"out_trade_no"</span>:<span class="string">"tradeprecreate15481691348134324306"</span>,<span class="string">"qr_code"</span>:<span class="string">"https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8"</span>&#125;,<span class="string">"sign"</span>:<span class="string">"K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="</span>&#125;</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.demo.trade.Main test_trade_precreate</span><br><span class="line">信息: 支付宝预下单成功: )</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.demo.trade.Main dumpResponse</span><br><span class="line">信息: code:<span class="number">10000</span>, msg:Success</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.demo.trade.Main dumpResponse</span><br><span class="line">信息: body:&#123;<span class="string">"alipay_trade_precreate_response"</span>:&#123;<span class="string">"code"</span>:<span class="string">"10000"</span>,<span class="string">"msg"</span>:<span class="string">"Success"</span>,<span class="string">"out_trade_no"</span>:<span class="string">"tradeprecreate15481691348134324306"</span>,<span class="string">"qr_code"</span>:<span class="string">"https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8"</span>&#125;,<span class="string">"sign"</span>:<span class="string">"K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="</span>&#125;</span><br><span class="line">一月 <span class="number">22</span>, <span class="number">2019</span> <span class="number">10</span>:<span class="number">58</span>:<span class="number">56</span> 下午 com.alipay.demo.trade.Main test_trade_precreate</span><br><span class="line">信息: filePath:/Users/sudo/Desktop/qr-tradeprecreate15481691348134324306.png</span><br></pre></td></tr></table></figure>



<p>交易创建的参数</p>
<ul>
<li>发送</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"out_trade_no"</span>: <span class="string">"tradeprecreate15481691348134324306"</span>, <span class="comment">//外部交易订单号</span></span><br><span class="line">  <span class="attr">"seller_id"</span>: <span class="string">""</span>, <span class="comment">//销售id</span></span><br><span class="line">  <span class="attr">"total_amount"</span>: <span class="string">"0.01"</span>, <span class="comment">//总金额</span></span><br><span class="line">  <span class="attr">"undiscountable_amount"</span>: <span class="string">"0"</span>, <span class="comment">//不参加折扣的金额</span></span><br><span class="line">  <span class="attr">"subject"</span>: <span class="string">"xxx品牌xxx门店当面付扫码消费"</span>, <span class="comment">//标题</span></span><br><span class="line">  <span class="attr">"body"</span>: <span class="string">"购买商品3件共20.00元"</span>, <span class="comment">//购买说明</span></span><br><span class="line">  <span class="comment">//商品详情</span></span><br><span class="line">  <span class="attr">"goods_detail"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"goods_id"</span>: <span class="string">"goods_id001"</span>, <span class="comment">//商品id</span></span><br><span class="line">      <span class="attr">"goods_name"</span>: <span class="string">"xxx小面包"</span>, <span class="comment">//商品名称</span></span><br><span class="line">      <span class="attr">"quantity"</span>: <span class="number">1</span>, <span class="comment">//商品数量</span></span><br><span class="line">      <span class="attr">"price"</span>: <span class="string">"10"</span> <span class="comment">//商品单价</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">"goods_id"</span>: <span class="string">"goods_id002"</span>,</span><br><span class="line">      <span class="attr">"goods_name"</span>: <span class="string">"xxx牙刷"</span>,</span><br><span class="line">      <span class="attr">"quantity"</span>: <span class="number">2</span>,</span><br><span class="line">      <span class="attr">"price"</span>: <span class="string">"5"</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">"operator_id"</span>: <span class="string">"test_operator_id"</span>, <span class="comment">//操作员的id</span></span><br><span class="line">  <span class="attr">"store_id"</span>: <span class="string">"test_store_id"</span>, <span class="comment">//店铺id</span></span><br><span class="line">  <span class="comment">//扩展字段</span></span><br><span class="line">  <span class="attr">"extend_params"</span>: &#123;</span><br><span class="line">    <span class="attr">"sys_service_provider_id"</span>: <span class="string">"2088100200300400500"</span> <span class="comment">//在回调时使用，交互时常用</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"timeout_express"</span>: <span class="string">"120m"</span> <span class="comment">//交易超时时间，120分钟</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ul>
<li>响应</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"code"</span>: <span class="string">"10000"</span>, <span class="comment">//响应码</span></span><br><span class="line">  <span class="attr">"msg"</span>: <span class="string">"Success"</span>, <span class="comment">//信息</span></span><br><span class="line">  <span class="attr">"out_trade_no"</span>: <span class="string">"tradeprecreate15481691348134324306"</span>, <span class="comment">//外部交易订单号</span></span><br><span class="line">  <span class="attr">"qr_code"</span>: <span class="string">"https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8"</span> <span class="comment">//二维码，可以通过base64方式传给前端展示，或者将二维码上传到后台ftp服务器进行展示</span></span><br><span class="line">&#125;,"sign": "K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用二维码生成器将返回的<code>qr_code</code>生成，用<em>支付宝沙箱版</em>进行扫码支付测试</p>
<p>至此，支付宝当面付的官方demo就调通了，可以进行后续开发</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title>Java对接支付宝支付功能（三）异步通知</title>
    <url>/2020/02/03/java-alipay-3/</url>
    <content><![CDATA[<p>支付宝回调异步通知的相关内容以及故障排查</p>
<a id="more"></a>

<h3 id="支付宝回调异步通知"><a href="#支付宝回调异步通知" class="headerlink" title="支付宝回调异步通知"></a>支付宝回调异步通知</h3><p><a href="https://docs.open.alipay.com/194/103296/" target="_blank" rel="noopener">当面付异步通知</a></p>
<p>当商户调用预下单请求API生成二维码展示给用户后，用户通过手机扫描二维码进行支付，支付宝会将该笔订单的变更信息，沿着商户调用预下单请求时所传入的通知地址主动推送给商户。</p>
<p>通知触发条件：交易状态为<code>TRADE_SUCCESS</code></p>
<h3 id="服务器异步通知页面特性"><a href="#服务器异步通知页面特性" class="headerlink" title="服务器异步通知页面特性"></a>服务器异步通知页面特性</h3><ol>
<li>必须保证服务器异步通知页面（notify_url）上无任何字符，如空格、HTML标签、开发系统自带抛出的异常提示信息等；</li>
<li>支付宝是用POST方式发送通知信息，因此该页面中获取参数的方式，如：request.Form(“out_trade_no”)、$_POST[‘out_trade_no’]；</li>
<li>支付宝主动发起通知，该方式才会被启用；</li>
<li>只有在支付宝的交易管理中存在该笔交易，且发生了交易状态的改变，支付宝才会通过该方式发起服务器通知（即时到账中交易状态为“等待买家付款”的状态默认是不会发送通知的）；</li>
<li>服务器间的交互，不像页面跳转同步通知可以在页面上显示出来，这种交互方式是不可见的；</li>
<li>第一次交易状态改变（即时到账中此时交易状态是交易完成）时，不仅会返回同步处理结果，而且服务器异步通知页面也会收到支付宝发来的处理结果通知；</li>
<li><strong>程序执行完后必须打印输出“success”（不包含引号）。</strong>如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）；</li>
<li>程序执行完成后，该页面不能执行页面跳转。（不能有重定向）如果执行页面跳转，支付宝会收不到success字符，会被支付宝服务器判定为该页面程序运行出现异常，而重发处理结果通知；</li>
<li>cookies、session等在此页面会失效，即无法获取这些数据；</li>
<li>该方式的调试与运行必须在服务器上，即互联网上能访问；（如果本地调试，需要使用内网穿透）</li>
<li>该方式的作用主要防止订单丢失，即页面跳转同步通知没有处理订单更新，它则去处理；</li>
<li><strong>当商户收到服务器异步通知并打印出success时，服务器异步通知参数notify_id才会失效。</strong>也就是说在支付宝发送同一条异步通知时（包含商户并未成功打印出success导致支付宝重发数次通知），服务器异步通知参数notify_id是不变的。</li>
</ol>
<h3 id="异步返回结果的验签"><a href="#异步返回结果的验签" class="headerlink" title="异步返回结果的验签"></a>异步返回结果的验签</h3><p>实例：某商户设置的通知地址为<a href="https://api.xx.com/receive_notify.htm%EF%BC%8C%E5%AF%B9%E5%BA%94%E6%8E%A5%E6%94%B6%E5%88%B0%E9%80%9A%E7%9F%A5%E7%9A%84%E7%A4%BA%E4%BE%8B%E5%A6%82%E4%B8%8B%EF%BC%9A" target="_blank" rel="noopener">https://api.xx.com/receive_notify.htm，对应接收到通知的示例如下：</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;api.xx.com&#x2F;receive_notify.htm?</span><br><span class="line">gmt_payment&#x3D;2015-06-11 22:33:59</span><br><span class="line">&amp;notify_id&#x3D;42af7baacd1d3746cf7b56752b91edcj34</span><br><span class="line">&amp;seller_email&#x3D;testyufabu07@alipay.com</span><br><span class="line">&amp;notify_type&#x3D;trade_status_sync</span><br><span class="line">&amp;sign&#x3D;kPbQIjX+xQc8F0&#x2F;A6&#x2F;AocELIjhhZnGbcBN6G4MM&#x2F;HmfWL4ZiHM6fWl5NQhzXJusaklZ1LFuMo+lHQUELAYeugH8LYFvxnNajOvZhuxNFbN2LhF0l&#x2F;KL8ANtj8oyPM4NN7Qft2kWJTDJUpQOzCzNnV9hDxh5AaT9FPqRS6ZKxnzM&#x3D;&amp;trade_no&#x3D;2015061121001004400068549373</span><br><span class="line">&amp;out_trade_no&#x3D;21repl2ac2eOutTradeNo322</span><br><span class="line">&amp;gmt_create&#x3D;2015-06-11 22:33:46</span><br><span class="line">&amp;seller_id&#x3D;2088211521646673</span><br><span class="line">&amp;notify_time&#x3D;2015-06-11 22:34:03</span><br><span class="line">&amp;subject&#x3D;FACE_TO_FACE_PAYMENT_PRECREATE中文</span><br><span class="line">&amp;trade_status&#x3D;TRADE_SUCCESS</span><br><span class="line">&amp;sign_type&#x3D;RSA2</span><br></pre></td></tr></table></figure>

<p><strong>第一步：</strong> 在通知返回参数列表中，除去sign、sign_type两个参数外，凡是通知返回回来的参数皆是待验签的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">logger.debug(<span class="string">"**********************支付宝回调开始**********************"</span>);		</span><br><span class="line"><span class="comment">// 得到并遍历回调传来的参数</span></span><br><span class="line">Map&lt;String, String[]&gt; requestParams = request.getParameterMap();</span><br><span class="line">Map&lt;String, String&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="comment">// 将前台的参数转换为"xxx"-&gt;"aaa,bbb"的格式存入params中,实际上回调传来的参数每个key都只对应一个value</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, String[]&gt; entry: requestParams.entrySet()) &#123;</span><br><span class="line">    String key = entry.getKey();</span><br><span class="line">    String values[] = entry.getValue();</span><br><span class="line">    StringBuilder valStr = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; values.length; i ++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ( i != values.length - <span class="number">1</span>) &#123;</span><br><span class="line">            valStr.append(values[i]).append(<span class="string">","</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            valStr.append(values[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    params.put(key, valStr.toString());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 日志打印回调信息，包括签名，支付状态，所有参数</span></span><br><span class="line">logger.info(<span class="string">"alipay_callback, sign:&#123;&#125;, trade_status:&#123;&#125;, params:&#123;&#125;"</span>, params.get(<span class="string">"sign"</span>), params.get(<span class="string">"trade_status"</span>),params.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要除去sign、sign_type两个参数，而sign已经在#rsaCheckV2方法中除去了</span></span><br><span class="line">params.remove(<span class="string">"sign_type"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>第二步：</strong> 将剩下参数进行url_decode, 然后进行字典排序，组成字符串，得到待签名字符串</p>
<p><strong>第三步：</strong> 将签名参数（sign）使用base64解码为字节码串。</p>
<p>​    第二步和第三步在支付宝提供的<code>rsaCheckV2</code>方法中已经实现</p>
<p><strong>第四步：</strong> 使用RSA的验签方法，通过签名字符串、签名参数（经过base64解码）及支付宝公钥验证签名。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 使用RSA的验签方法，通过签名字符串、签名参数（经过base64解码）及支付宝公钥验证签名</span></span><br><span class="line">    <span class="keyword">boolean</span> rsaCheckV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), <span class="string">"utf-8"</span>, Configs.getSignType());</span><br><span class="line">	<span class="comment">// 验签失败</span></span><br><span class="line">	<span class="keyword">if</span> ( !rsaCheckV2 ) &#123;</span><br><span class="line">	<span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"验签失败，检测到非法请求"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (AlipayApiException e) &#123;</span><br><span class="line">	logger.error(<span class="string">"支付宝回调异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是rsaCheckV2有两个重载的方法，一个是带signType参数的，我们需要使用这个方法指定签名类型为RSA2（可以从之前装配的Configs类直接获取），而不带signType的方法默认使用SHA1WithRSA的类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 支付宝提供的验签方法，内部已经实现了除去sign参数、字典排序成待签名字符串、将sign使用base64解码为字节码串</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">rsaCheckV2</span><span class="params">(Map&lt;String, String&gt; params, String publicKey,</span></span></span><br><span class="line"><span class="function"><span class="params">            String charset,String signType)</span> <span class="keyword">throws</span> AlipayApiException </span>&#123;</span><br><span class="line">    String sign = params.get(<span class="string">"sign"</span>);</span><br><span class="line">    String content = getSignCheckContentV2(params);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rsaCheck(content, sign, publicKey, charset,signType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getSignCheckContentV2</span><span class="params">(Map&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (params == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    params.remove(<span class="string">"sign"</span>);</span><br><span class="line"></span><br><span class="line">    StringBuffer content = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">    List&lt;String&gt; keys = <span class="keyword">new</span> ArrayList&lt;String&gt;(params.keySet());</span><br><span class="line">    Collections.sort(keys);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; keys.size(); i++) &#123;</span><br><span class="line">    String key = keys.get(i);</span><br><span class="line">    String value = params.get(key);</span><br><span class="line">    content.append((i == <span class="number">0</span> ? <span class="string">""</span> : <span class="string">"&amp;"</span>) + key + <span class="string">"="</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> content.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">rsaCheck</span><span class="params">(String content, String sign, String publicKey, String charset,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   String signType)</span> <span class="keyword">throws</span> AlipayApiException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (AlipayConstants.SIGN_TYPE_RSA.equals(signType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rsaCheckContent(content, sign, publicKey, charset);</span><br><span class="line">        <span class="comment">// 这里使用的是RSA2的签名方法</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AlipayConstants.SIGN_TYPE_RSA2.equals(signType)) &#123;</span><br><span class="line">        <span class="keyword">return</span> rsa256CheckContent(content, sign, publicKey, charset);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AlipayApiException(<span class="string">"Sign Type is Not Support : signType="</span> + signType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>第五步：需要严格按照如下描述校验通知数据的正确性。</strong></p>
<p><strong>商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，并判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），同时需要校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方（有的时候，一个商户可能有多个seller_id/seller_email），上述有任何一个验证不通过，则表明本次通知是异常通知，务必忽略。在上述验证通过后商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。在支付宝的业务通知中，只有交易通知状态为TRADE_SUCCESS或TRADE_FINISHED时，支付宝才会认定为买家付款成功。</strong></p>
<p><strong>注意：</strong></p>
<ul>
<li><p>状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功；</p>
</li>
<li><p>交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 商户需要校验通知数据的正确性</span></span><br><span class="line">ServerResponse serverResponse = iOrderService.alipayCallback(params);</span><br><span class="line"><span class="comment">// 校验成功，一定要打印出“success”</span></span><br><span class="line"><span class="keyword">if</span> (serverResponse.isSuccuess()) &#123;</span><br><span class="line"><span class="keyword">return</span> Const.AlipayCallback.RESPONSE_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> Const.AlipayCallback.RESPONSE_FAILED;</span><br></pre></td></tr></table></figure>

<p>  商户需要依次校验通知数据的正确性</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerResponse <span class="title">alipayCallback</span><span class="params">(Map&lt;String, String&gt; params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 支付宝外部订单号，也就是商城订单号</span></span><br><span class="line">    Long orderNo = Long.valueOf(params.get(<span class="string">"out_trade_no"</span>));</span><br><span class="line">    logger.debug(<span class="string">"out_trade_no: &#123;&#125;"</span>, orderNo.toString());</span><br><span class="line">    <span class="comment">// 支付宝交易号</span></span><br><span class="line">    String tradeNo = params.get(<span class="string">"trade_no"</span>);</span><br><span class="line">    <span class="comment">// 交易状态</span></span><br><span class="line">    String tradeStatus = params.get(<span class="string">"trade_status"</span>);</span><br><span class="line">    logger.debug(<span class="string">"trade_status: &#123;&#125;"</span>, tradeStatus);</span><br><span class="line">    Order order = orderMapper.selectByOrderNo(orderNo);</span><br><span class="line">    <span class="keyword">if</span> (order == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createByErrorMessage(<span class="string">"不是该商城订单，忽略回调"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断交易状态</span></span><br><span class="line">    <span class="comment">// 交易状态为已付款，已发货，订单完成，订单关闭时，为重复调用</span></span><br><span class="line">    <span class="keyword">if</span> (order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123;</span><br><span class="line">        <span class="keyword">return</span> ServerResponse.createBySuccess(<span class="string">"支付宝重复调用"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 交易成功，记录付款时间，更新订单状态为已付款</span></span><br><span class="line">    <span class="keyword">if</span> (Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123;</span><br><span class="line">        order.setPaymentTime(DateTimeUtil.strToDate(params.get(<span class="string">"gmt_payment"</span>)));</span><br><span class="line">        order.setStatus(Const.OrderStatusEnum.PAID.getCode());</span><br><span class="line">        orderMapper.updateByPrimaryKeySelective(order);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 组装支付信息对象，略</span></span><br><span class="line">	...</span><br><span class="line">    <span class="keyword">return</span> ServerResponse.createBySuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="回调出错的排查"><a href="#回调出错的排查" class="headerlink" title="回调出错的排查"></a>回调出错的排查</h3><p>如果回调出现问题，支付宝提供了一些自查方案可以先自行排查</p>
<p><a href="https://openclub.alipay.com/read.php?tid=1677&fid=25&page=1" target="_blank" rel="noopener">收不到异步通知自查方案-支付宝接口常见错误系列</a></p>
<p><a href="https://openclub.alipay.com/read.php?tid=675&fid=60" target="_blank" rel="noopener">收不到异步通知「自检方案」</a></p>
<ol>
<li>需http://或者https://格式的完整路径<br>  例：https://您的域名/notify_url.php  ，支持ip地址方式。（<strong>推荐使用域名</strong>） </li>
<li>不能加?id=123这类自定义参数<br>  错误示例：https://您的域名/notify_url.php？id=123&amp;test=abc </li>
<li>必须外网可以正常访问，这个不难理解，在您的异步地址没有代码逻辑的情况下，直接访问应该是一个空白    页面并且http状态是200（不支持http200以外的状态） </li>
<li>不能有重定向 如：http302 </li>
<li>使用POST方式接收，请确保服务器路由已经开放POST通知 </li>
</ol>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title>从浏览器输入URL到页面加载展示，中间发生了什么</title>
    <url>/2020/02/09/url-to-webpage/</url>
    <content><![CDATA[<p>页面加载整体流程分析，主要包括浏览器处理URL、DNS解析、获取TCP连接、发送HTTP请求、服务器处理请求、服务器返回响应、浏览器渲染页面这几大步骤。</p>
<a id="more"></a>

<p>这是一个面试中常会遇到的问题，其中涉及的问题很多，接下来会试着一一分析一下。</p>
<p>具体过程主要分为浏览器处理URL、DNS解析、获取TCP连接、发送HTTP请求、服务器处理请求、服务器返回响应、浏览器渲染页面这几大步骤。</p>
<p>本文以输入<a href="http://www.google.com/" target="_blank" rel="noopener">www.google.com</a> 为例进行分析，浏览器以chrome为例。</p>
<hr>
<h3 id="浏览器处理URL"><a href="#浏览器处理URL" class="headerlink" title="浏览器处理URL"></a>浏览器处理URL</h3><h4 id="1-校验URL格式"><a href="#1-校验URL格式" class="headerlink" title="1. 校验URL格式"></a>1. 校验URL格式</h4><p>首先，浏览器会校验用户输入的URL格式是否正确，如果不是URL地址，那么浏览器会自动调用默认的搜索引擎进行搜索。</p>
<p>合法的URL地址如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scheme&gt;:&#x2F;&#x2F;&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;&#x2F;&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt;</span><br></pre></td></tr></table></figure>

<p>URL 为了在不同协议不同传输机制都可以安全的运送信息，采用的字符都是符合 ASCII 集的。这其中还包含一些保留字符，比如上面的 URL 协议中的分割字符，等特殊含义的字符。<br>而不安全的字符，非 ASCII 的 Unicode（中文等）字符，就会通过转义去处理，使用% 。</p>
<p>此部分就是检查 url 的合法性，并对不合法的进行转义。浏览器还会检查 HSTS 列表。</p>
<h4 id="2-检查HSTS-列表"><a href="#2-检查HSTS-列表" class="headerlink" title="2. 检查HSTS 列表"></a>2. 检查HSTS 列表</h4><p>HSTS 就是一种安全策略的机制，是为了让浏览器强制使用 HTTPS 访问的，详细可以去这篇<a href="http://www.jianshu.com/p/caa80c7ad45c" target="_blank" rel="noopener">文章</a>看，介绍的比较清楚。当你的网站均采用 HTTPS，并符合它的安全规范，就可以申请加入 HSTS 列表，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。</p>
<p>例如用户输入<code>google.com</code> ，最终会定向到<code>https://www.google.com/</code>。</p>
<p><img src="/2020/02/09/url-to-webpage/1549786677960.png" alt="1549786677960"></p>
<h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>我们浏览器中输入的地址只是一个代号，服务器是不认识这个名称的，服务器需要IP地址来进行定位。</p>
<p>通过DNS（Domain Name System）域名系统解析，我们可以把url转换为IP地址</p>
<h4 id="1-查询缓存"><a href="#1-查询缓存" class="headerlink" title="1. 查询缓存"></a>1. 查询缓存</h4><h5 id="1-1-查看浏览器内部缓存"><a href="#1-1-查看浏览器内部缓存" class="headerlink" title="1.1 查看浏览器内部缓存"></a>1.1 查看浏览器内部缓存</h5><p>检测域名是否存在于浏览器缓存中，如果有缓存直接使用，没有则下一步。打开 <code>chrome://net-internals/#dns</code> 即可查看本机浏览器的 dns 缓存。（chrome中有效期为1分钟）</p>
<h5 id="1-2-系统缓存"><a href="#1-2-系统缓存" class="headerlink" title="1.2 系统缓存"></a>1.2 系统缓存</h5><p>浏览器会调用一个库函数，此函数会先去检测本地 hosts文件，查看是否有对应ip。</p>
<h5 id="1-3-路由器缓存、ISP-缓存"><a href="#1-3-路由器缓存、ISP-缓存" class="headerlink" title="1.3. 路由器缓存、ISP 缓存"></a>1.3. 路由器缓存、ISP 缓存</h5><p>如果浏览器和系统缓存都没有，系统的库函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。</p>
<h4 id="2-本地-DNS-服务器"><a href="#2-本地-DNS-服务器" class="headerlink" title="2. 本地 DNS 服务器"></a>2. 本地 DNS 服务器</h4><p>windows下利用<code>ipconfig</code>命令可以查看本机DNS服务器地址</p>
<p><img src="/2020/02/09/url-to-webpage/1549802306452.png" alt="1549802306452"></p>
<h4 id="3-域名服务器"><a href="#3-域名服务器" class="headerlink" title="3. 域名服务器"></a>3. 域名服务器</h4><p>如果本机DNS没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。</p>
<p>关于根域名服务器的介绍以及为什么是13台，可以去这篇<a href="https://jaminzhang.github.io/dns/The-Reason-of-There-Is-Only-13-DNS-Root-Servers/" target="_blank" rel="noopener">文章</a> 看，讲的很明白。</p>
<p>到此处的过程为：根域服务器（.） -&gt; 顶级域名服务器（.com）-&gt; 主域名服务器（google.com）</p>
<p>经过以上这些查询，如果域名正常，在某一步骤应该就会返回 IP 地址，如果直到最后一步都没有查询到，浏览器就会提示找不到服务器地址。</p>
<p><strong>得到目标服务器地址后，可以进行TCP连接了。</strong></p>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP协议（Transmission Control Protocol，传输控制协议）是一种面向连接，确保数据在端到端之间可靠传输的协议。由于TCP协议十分复杂，这里仅作简单介绍。</p>
<p><strong>TCP header</strong></p>
<p><img src="https://nmap.org/book/images/hdr/MJB-TCP-Header-800x564.png"></p>
<p>根据TCP/IP协议，需要本机和目标服务器的<code>ip</code>和<code>port</code>才能进行传输。</p>
<p>本机ip：由操作系统分配                本机port：由操作系统分配</p>
<p>目标服务器ip：通过DNS解析            目标服务器port：http协议默认80，https协议默认443</p>
<h4 id="建立TCP连接"><a href="#建立TCP连接" class="headerlink" title="建立TCP连接"></a>建立TCP连接</h4><p>TCP有6个标志位，分别为SYN, ACK, FIN, URG, PSH, RST。置一有效。</p>
<p>这里介绍SYN，ACK， FIN这3个标志位。</p>
<p>SYN（Synchronize Sequence Number）: 建立连接的同步信号</p>
<p>ACK（Acknowledgement）: 对收到的数据进行确认</p>
<p>FIN（Finish）: 表示后面没有数据要发送，连接需要关闭</p>
<p>还需要用到两个序号，序列号seq和确认序号ack</p>
<p>seq（sequence number）：表示要发送的数据的第一个字节的序号，后面按这个逻辑递增</p>
<p>ack（Acknowledgement number）：期望收到的下一个报文段数据的第一个字节的序号</p>
<p>3次握手的过程如下图所示</p>
<p><img src="/2020/02/09/url-to-webpage/1549789979776.png" alt="1549789979776"></p>
<p><strong>为什么要三次挥手来建立连接？</strong></p>
<p>主要是要初始化Sequence Number(seq) 的初始值。seq要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。</p>
<p><strong>为什么是三次而不是两次</strong>？</p>
<p>主要因为<strong>信息对等</strong>和<strong>防止超时</strong></p>
<p><strong>信息对等</strong>：如果只进行2次握手，B机器无法确认A收到了自己的信息，只有通过第3次握手，才能确认自己的发报能力和收报能力都是正常的</p>
<p><img src="/2020/02/09/url-to-webpage/1549791850506.png" alt="1549791850506"></p>
<p><strong>防止超时</strong>：TTL网络报文的生存时间往往都会超过TCP请求超时时间，如果只用2次握手建立连接，那么当A机器发送第一个请求超时，第二个请求才和B机器建立连接，当A发送的第一 个超时请求这个时候才到达B时，B机器会建立一个新的连接，然而，由于A的状态不是SYN_SENT，会直接丢弃B的确认数据，导致B单方面创建连接完毕。</p>
<p><img src="/2020/02/09/url-to-webpage/1549791947646.png" alt="1549791947646"></p>
<h4 id="断开TCP连接"><a href="#断开TCP连接" class="headerlink" title="断开TCP连接"></a>断开TCP连接</h4><p>建立连接需要3次，而断开连接需要4次挥手。主要过程见下图。</p>
<p><img src="/2020/02/09/url-to-webpage/1549794267158.png" alt="1549794267158"></p>
<p>这里主要介绍一下<code>CLOSE_WAIT</code>和<code>TIME_WAIT</code>这两个状态。</p>
<ul>
<li><p><code>CLOSE_WAIT</code>: 该状态表示等待关闭，并通知应用程序发送剩余数据，处理现场信息，关闭相关资源。</p>
</li>
<li><p><code>TIME_WAIT</code>:  主动要求关闭的机器在收到对方的FIN报文后，发送ACK报文，并进入TIME_WAIT状态，等待<code>2MSL</code>后即可进入<code>CLOSED</code>关闭状态。</p>
</li>
</ul>
<p>MSL(Maximum Segment Lifetime)，等待<code>2MSL</code>是报文在网络上生存的最长时间，超过阈值报文则被丢弃，一般来说<code>MSL</code>大于TTL衰减至0的时间。在RFC793中规定<code>MSL</code>为2分钟，然而在当前告诉网络中，2分钟等待时间会造成极大的资源浪费，在高并发服务器上通常会使用更小的值。</p>
<p><strong>既然<code>TIME_WAIT</code>这个状态看起很鸡肋，为何不直接进入<code>CLOSED</code>状态呢？</strong></p>
<p>主要有两点原因：</p>
<p><strong>第一，确认被动关闭方能够顺利进入CLOSED状态。</strong>如果最后一个ACK没有到达B机器，B机器会重发FIN+ACK报文，当A机器收到了第二次FIN+ACK报文，会重发一次ACK，并重新计时。如果A没有等待时间而是发送完ACK后直接关闭，可能会导致B机器无法确保收到最后的ACK指令。</p>
<p><strong>第二，防止失效请求。</strong>防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。</p>
<p>RFC793定义了MSL为2分钟，Linux设置成了30s，在服务器上通过变更<code>/etc/sysctl.conf</code>文件修改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_fin_timeout &#x3D; 30</span><br></pre></td></tr></table></figure>



<p><strong>服务器上<code>TIME_WAIT</code>状态过多的原因？</strong></p>
<p>如果在大并发的短链接下，此状态可能过多，可通过优化服务器参数得到解决<code>vim /etc/sysctl.conf</code><br>编辑文件，选择添加以下内容：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">net.ipv4.tcp_syncookies = 1</span><br><span class="line">net.ipv4.tcp_tw_reuse = 1</span><br><span class="line">net.ipv4.tcp_tw_recycle = 1</span><br><span class="line">net.ipv4.tcp_fin_timeout = 30</span><br></pre></td></tr></table></figure>

<p>然后执行 <code>/sbin/sysctl -p </code>让参数生效。</p>
<p><code>net.ipv4.tcp_syncookies = 1</code> 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击。<strong>请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，syncookies是妥协版的TCP协议，并不严谨。</strong>默认为0，表示关闭；<br><code>net.ipv4.tcp_tw_reuse = 1 </code>表示开启重用。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下<a href="http://lxr.free-electrons.com/ident?i=tcp_twsk_unique" target="_blank" rel="noopener">tcp_twsk_unique</a>的源码 ）。默认为0，表示关闭；<br><code>net.ipv4.tcp_tw_recycle = 1</code> 表示开启TCP连接中TIME-WAIT sockets的快速回收。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建连接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）。默认为0，表示关闭。<br><strong>使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（<a href="http://tools.ietf.org/html/rfc1122" target="_blank" rel="noopener">RFC 1122</a>)</strong> </p>
<p><strong>服务器上<code>CLOSE_WAIT</code>状态过多的原因？</strong></p>
<p>对方关闭socket连接，我方忙于读或写，没有及时关闭连接。</p>
<p>检查代码，特别是释放资源的代码</p>
<p>检查配置，特别是处理请求的线程配置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看443端口上CLOSE_WAIT状态的命令</span></span><br><span class="line">netstat -ant | grep -i "443" | grep CLOSE_WAIT | wc-1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 统计各个状态的连接数</span></span><br><span class="line">netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;'</span><br></pre></td></tr></table></figure>



<p><strong>为什么需要四次挥手才能断开连接？</strong></p>
<p>因为TCP建立的是全双工连接，发送方和接收方都需要FIN报文和ACK报文。</p>
<h4 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h4><p><a href="http://www.tcpipguide.com/free/t_TCPSlidingWindowAcknowledgmentSystemForDataTranspo.htm" target="_blank" rel="noopener">The TCP/IP Guide</a>中有详细的解说</p>
<p>TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能：</p>
<p><strong>可靠性</strong>：保证数据确实到达目的地。如果未到达，能够发现并重传。</p>
<p><strong>数据流控</strong>：管理数据的发送速率，以使接收设备不致于过载。</p>
<p>要完成这些任务，整个协议操作是围绕<strong>滑动窗口确认机制</strong>来进行的。因此，理解了滑动窗口，也就是理解了TCP。</p>
<ul>
<li>发送方的滑动窗口示意图</li>
</ul>
<p><img src="http://www.tcpipguide.com/free/diagrams/tcpswwindows.png"></p>
<p>图中分为4个部分，其中黑色方框框出的部分就是滑动窗口</p>
<p><strong>1.</strong> <strong>已发送已确认</strong> 数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如上图所示，31个字节已经发送并确认。</p>
<p><strong>2.</strong> <strong>已发送但尚未确认</strong> 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图所示14字节为第2类。</p>
<p><strong>3.</strong> <strong>未发送而接收方已Ready</strong> 设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。如图，第3类有6字节。</p>
<p><strong>4.</strong> <strong>未发送而接收方Not Ready</strong> 由于接收方not ready，还不允许将这部分数据发出。</p>
<ul>
<li>滑动后窗口示意图</li>
</ul>
<p>当发送方接收到一系列字节的确认时，它知道数据被接收方成功地接收了，发送方将这些数据从“已发送但未确认”移动到“已发送已确认”。这样使得滑动窗口向右滑动，允许发送发发送更多数据。</p>
<p><img src="http://www.tcpipguide.com/free/diagrams/tcpswslide.png" alt="img"></p>
<h3 id="发送HTTPS请求"><a href="#发送HTTPS请求" class="headerlink" title="发送HTTPS请求"></a>发送HTTPS请求</h3><p><strong>TCP连接建立后，客户端向浏览器发送HTTP请求。</strong></p>
<p>现在很多网站都使用https协议替代了http协议。</p>
<p>HTTPS全称为HTTP over SSL。其中，SSL（Secure Socket Layer）安全套接字层，是一个工作于应用层和传输层之间，为应用提供加密传输的协议。顾名思义，HTTPS就是在HTTP上增加了SSL协议的加密能力。</p>
<h4 id="关于数字加密"><a href="#关于数字加密" class="headerlink" title="关于数字加密"></a>关于数字加密</h4><p>这里需要补充一点数字加密的相关知识，在另一篇<a href="https://www.wuleshen.com/2019/02/13/digitalSignature/#more">文章</a>中提及。</p>
<h4 id="HTTPS建立连接"><a href="#HTTPS建立连接" class="headerlink" title="HTTPS建立连接"></a>HTTPS建立连接</h4><p>HTTPS建立连接步骤大致如下：</p>
<ol>
<li>客户端向服务端发送请求，客户端会告诉服务端自己支持哪些加密套件</li>
<li>服务端收到请求后，会返回一系列协议数据，并以一个没有数据内容的Server Hello Done 作为结束。</li>
<li>客户端在收到服务端的握手信息后，也会发送一系列协议。</li>
<li>服务端在接收客户端的确认信息和验证信息后，会对客户端发送的数据进行确认。</li>
<li>最后，如果双方都确认加密无误后，各自按照之前约定的Session Secret对应用数据进行加密传输。</li>
</ol>
<p>具体的协议数据等，可以通过抓包工具进行查看，这里就不做展开了。</p>
<p><img src="/2020/02/09/url-to-webpage/1549807179453.png" alt="1549807179453"></p>
<h3 id="服务器处理请求"><a href="#服务器处理请求" class="headerlink" title="服务器处理请求"></a>服务器处理请求</h3><h4 id="WEB服务器"><a href="#WEB服务器" class="headerlink" title="WEB服务器"></a>WEB服务器</h4><p>如果后端采用WEB服务器和应用服务器的架构，请求先到达WEB服务器，然后在由WEB服务器转发到某个应用服务器。</p>
<p>常见的WEB服务器有Nginx</p>
<p>Nginx利用epoll的方式读取请求，判断请求类型。</p>
<p><strong>对于静态请求：</strong>读取服务器硬盘上的相关文件，直接返回</p>
<p><strong>对于动态请求：</strong>转发到应用服务器（这里假设为Tomcat），如果有多个应用服务器，需要采用策略（负载均衡）</p>
<h4 id="应用服务器"><a href="#应用服务器" class="headerlink" title="应用服务器"></a>应用服务器</h4><p>常用的应用服务器有Tomcat</p>
<p>Tomcat是一个由Java编写的可以运行Servlet/JSP的容器，Javaweb的代码运行在这个容器上</p>
<p>Tomcat会采用阻塞I/O(Blocking I/O)或者I/O多路复用技术(NIO)</p>
<ul>
<li>BIO: 为每个请求分配一个线程去处理 </li>
<li>NIO: 监听所有的连接，当连接状态发生变化，才用一个线程/进程对那个连接进行处理，处理完继续监视</li>
</ul>
<h3 id="服务器返回响应"><a href="#服务器返回响应" class="headerlink" title="服务器返回响应"></a>服务器返回响应</h3><p>Http请求到达应用服务器后，会被交给某个Servlet处理。</p>
<p>如果使用框架（SpringMVC），DispatcherServlet会处理收到的请求。经过处理器映射器，处理器适配器交给Controller执行，返回的模型视图（ModelAndView）对象会交给视图解析器（ViewResolver）</p>
<h3 id="浏览器渲染页面"><a href="#浏览器渲染页面" class="headerlink" title="浏览器渲染页面"></a>浏览器渲染页面</h3><p>视图解析器内部调用render方法，将Model数据填充到View中，最终将View包装成Response传给浏览器。</p>
<p>浏览器从HTTPResponse中读取数据，准备显示页面。</p>
<p>由于HTML中可能引用大量其他资源，例如js，css，图片等，浏览器会下载这些资源（从DNS获取IP地址开始）</p>
<p>当服务器发给客户端资源文件时，会告知何时过期（使用Cache-control或者Expire），客户端可以把文件缓存到本地，下次再有请求时，如果没有过期，可以直接从本地缓存读取。如果过期，客户端会询问服务器资源是否被修改（依据上一次服务器发送的Last-Modified），如果未被修改（状态码304 Not Modified），可以继续使用缓存，否则服务器会发送最新的资源到客户端。</p>
<hr>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://github.com/sunyongjian/blog/issues/34" target="_blank" rel="noopener">https://github.com/sunyongjian/blog/issues/34</a></li>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li>
<li><a href="https://www.cnblogs.com/crazylqy/p/7110357.html" target="_blank" rel="noopener">https://www.cnblogs.com/crazylqy/p/7110357.html</a></li>
<li><a href="https://www.cnblogs.com/derekchen/archive/2011/02/26/1965839.html" target="_blank" rel="noopener">https://www.cnblogs.com/derekchen/archive/2011/02/26/1965839.html</a></li>
<li>《码出高效 Java开发手册》</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>Web</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
</search>
