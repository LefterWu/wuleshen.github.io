<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[centOS下安装redis]]></title>
    <url>%2F2019%2F03%2F05%2Flinux-install-redis%2F</url>
    <content type="text"><![CDATA[1. 安装 官网下载地址 https://redis.io/download linux下分别输入 12345$ wget http://download.redis.io/releases/redis-5.0.3.tar.gz$ tar xzf redis-5.0.3.tar.gz$ cd redis-5.0.3$ make$ make install 2. 编辑redis.conf配置文件由于redis默认在前台运行，我们希望它能够以守护进程的形式在后台运行，需要配置一下redis.conf 12$ cd redis-5.0.3$ vim redis.conf 找到daemonize，修改为yes，:wq保存 12345################################# GENERAL ###################################### By default Redis does not run as a daemon. Use &apos;yes&apos; if you need it.# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.daemonize yes 3. 启动redis12# 启动并加载配置文件$ redis-server redis.conf 12345678910# 启动详情[lefter@shen redis-5.0.3]$ redis-server redis.conf8256:C 05 Mar 2019 14:40:56.851 # oO0OoO0OoO0Oo Redis is starting oO0OoO0OoO0Oo8256:C 05 Mar 2019 14:40:56.851 # Redis version=5.0.3, bits=64, commit=00000000, modified=0, pid=8256, just started8256:C 05 Mar 2019 14:40:56.851 # Configuration loaded# 查看进程[lefter@shen redis-5.0.3]$ ps aux | grep redislefter 8257 0.6 0.4 152416 7804 ? Ssl 14:40 0:00 redis-server 127.0.0.1:6379lefter 8262 0.0 0.0 103328 856 pts/0 S+ 14:41 0:00 grep redis 12345# 启动redis命令行$ redis-cli# 关闭redis$ redis-cli shutdown 4. 关于jedis访问的配置Redis默认配置只绑定了本地访问，bind 127.0.0.1 由于我的Redis装在虚拟机中，需要在redis.conf中添加绑定虚拟机地址，如下： bind 192.168.163.129 12345678910111213141516171819202122232425################################## NETWORK ###################################### By default, if no "bind" configuration directive is specified, Redis listens# for connections from all the network interfaces available on the server.# It is possible to listen to just one or multiple selected interfaces using# the "bind" configuration directive, followed by one or more IP addresses.## Examples:## bind 192.168.1.100 10.0.0.1# bind 127.0.0.1 ::1## ~~~ WARNING ~~~ If the computer running Redis is directly exposed to the# internet, binding to all the interfaces is dangerous and will expose the# instance to everybody on the internet. So by default we uncomment the# following bind directive, that will force Redis to listen only into# the IPv4 loopback interface address (this means Redis will be able to# accept connections only from clients running into the same computer it# is running).## IF YOU ARE SURE YOU WANT YOUR INSTANCE TO LISTEN TO ALL THE INTERFACES# JUST COMMENT THE FOLLOWING LINE.# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~bind 127.0.0.1bind 192.168.163.129 # 在这里添加新的绑定]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java执行机制]]></title>
    <url>%2F2019%2F03%2F04%2Fjava-execution-principle%2F</url>
    <content type="text"><![CDATA[Java执行机制首先，Java平台如今的主流版本（JDK8以上，HotSpot VM）中，主要采用混合模式进行代码执行。 Java主要使用JIT动态编译与解释器混合执行。 JIT编译器，英文写作Just-In-Time Compiler，中文意思是即时编译器。 JIT 编译过程当 JIT 编译启用时（默认是启用的），JVM 读入.class 文件解释后，将其发给 JIT 编译器。JIT 编译器将字节码编译成本机机器代码。 具体来说，Java有热点代码编译功能，通过统计热点代码，将热点代码通过JIT编译成机器码交并存入Code Cache，而其余代码则由JVM解释执行。 Hot Spot 编译当 JVM 执行代码时，它并不立即开始编译代码。这主要有两个原因： 首先，如果这段代码本身在将来只会被执行一次，那么从本质上看，编译就是在浪费精力。因为将代码翻译成 java 字节码相对于编译这段代码并执行代码来说，要快很多。 当然，如果一段代码频繁的调用方法，或是一个循环，也就是这段代码被多次执行，那么编译就非常值得了。因此，编译器具有的这种权衡能力会首先执行解释后的代码，然后再去分辨哪些方法会被频繁调用来保证其本身的编译。其实说简单点，就是 JIT 在起作用，我们知道，对于 Java 代码，刚开始都是被编译器编译成字节码文件，然后字节码文件会被交由 JVM 解释执行，所以可以说 Java 本身是一种半编译半解释执行的语言。Hot Spot VM 采用了 JIT compile 技术，将运行频率很高的字节码直接编译为机器指令执行以提高性能，所以当字节码被 JIT 编译为机器码的时候，要说它是编译执行的也可以。也就是说，运行时，部分代码可能由 JIT 翻译为目标机器指令（以 method 为翻译单位，还会保存起来，第二次执行就不用翻译了）直接执行。 第二个原因是最优化，当 JVM 执行某一方法或遍历循环的次数越多，就会更加了解代码结构，那么 JVM 在编译代码的时候就做出相应的优化。 举一个简单的例子：我们知道equals()这个方法存在于每一个 Java Object 中而且经常被覆写。当解释器遇到b = obj1.equals(obj2)这样一句代码，它则会查询 obj1 的类型从而得知到底运行哪一个 equals() 方法。而这个动态查询的过程从某种程度上说是很耗时的。 具体案例放到具体生产环境，这种执行方式造成了机器在热机状态可以承受的负载要大于冷机状态。 如果以热机状态时的流量进行切流，可能使处于冷机状态的服务器因无法承载流量而假死。 案例： 某程序员在发布平台进行分批发布，在输入发布总批数时，误填写成两批发布， 如果是热机状态，正常情况下一半的机器可以勉强承载流量，但由于刚启动时的JVM均为解释执行，没有进行热点代码统计和JIT动态编译，导致当前1/2发布成功的服务器马上全部宕机。 参考 《码出高效——Java开发手册》 深入浅出 JIT 编译器]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
        <tag>JIT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[volatile关键字和synchronized关键字的区别]]></title>
    <url>%2F2019%2F02%2F27%2Fvolatile-and-synchronized%2F</url>
    <content type="text"><![CDATA[一句话概括 volatile保证了线程间的可见性和有序性 synchronized保证了线程间的原子性（同时保证了可见性和有序性） Java内存模型首先，为了说明两者的区别，先要引出一个概念——Java内存模型(JMM)，该模型用于屏蔽各种硬件和操作系统带来的内存访问的差异，定义了程序中各个变量（不包括局部变量和方法参数，因为这些是线程私有的）的访问规则。 JMM规定所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取，赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成 需要注意的是，这里Java内存模型中的主内存，工作内存和Java内存区域中的Heap，Stack，方法区等是没有关系的，如果非要类比，主内存可以对应Heap中的对象实例的数据部分，工作内存对应JVM Stack中的部分区域。 volatile语义volatile关键字可以说是Java虚拟机提供的最轻量级的同步机制。 当一个变量定义为volatile时，它将具备两种特性： 第一，保证此变量对所有线程的可见性。这里的可见性指的是当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量不能做到这一点，普通变量的值在线程间传递都需要通过主内存来完成。 第二，禁止指令重排序优化。 举例说明如下图所示，有两个线程t1和t2，它们都需要使用对象A中的变量flag，这两个线程都会从主内存中copy一份对象A的变量flag，放到它们各自的线程工作内存中，然后在运行期间直接使用这份copy。 当t2线程需要修改flag的值，它会先把自己工作区的flag修改然后存入主内存中，但是t1并不会去访问heap中的flag，而是依旧使用自己工作区的copy。 当volatile关键字作用到变量flag上，将会强制所有线程都去主线程中读取变量flag的值。 示例代码 1234567891011121314151617181920212223242526272829303132/** * 示例代码中有两个线程，主线程和main方法中启动的线程t1 */public class T &#123; /*volatile*/ boolean flag = true; //对比一下有无volatile的情况下，整个程序运行结果的区别 public void m() &#123; System.out.println("m start"); while(flag) &#123; &#125; System.out.println("m end!"); &#125; public void shutdown() &#123; flag = false; &#125; public static void main(String[] args) &#123; T t = new T(); new Thread(t::m, "t1").start(); try &#123; TimeUnit.SECONDS.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; // 主线程更改flag的值 shutdown(); &#125; &#125; 以上代码开启了一个线程t1，该线程执行m方法，如果不加volatile关键字，在主线程中更改flag的值，并不会使循环停止，这是由于t1线程执行时使用的是来自主线程的拷贝，并不会在执行时访问主线程，而volatile关键词使得主线程对flag的修改对于线程t1来说是可见的，t1会刷新flag的值并结束循环。 使用场景由于volatile变量只能保证可见性，在不符合以下两条规则的场景中，我们仍需要通过加锁（使用synchronized或java.util.concurrent中的Atomic类）来保证原子性。 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值 变量不需要与其他的状态变量共同参与不变约束 前面举的列子就很适合使用volatile变量来控制并发，当shutdown()被调用时，能保证所有线程中的m()方法立即停止。 大多数情况下使用volatile比synchronized开销低，选择的唯一依据就是我们是否在保证可见性和有序性的基础上，还需要保证原子性。]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo博客SEO优化]]></title>
    <url>%2F2019%2F02%2F14%2Fhexo-blog-seo-optimization%2F</url>
    <content type="text"><![CDATA[为了让我们的博客被搜索引擎爬取和收录，我们需要对博客进行SEO优化。 搜索引擎优化（英语：search engine optimization，缩写为SEO），是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。 站点地图站点地图描述了一个网站的架构 它可以是一个任意形式的文档，用作网页设计的设计工具，也可以是列出网站中所有页面的一个网页，通常采用分级形式。这有助于访问者以及搜索引擎的机器人找到网站中的页面。 站点地图的作用 为搜索引擎爬虫提供可以浏览整个网站的链接； 为搜索引擎爬虫提供一些链接，指向动态页面或者采用其他方法比较难以到达的页面； 如果访问者试图访问网站所在域内并不存在的URL，那么这个访问者就会被转到“无法找到文件”的错误页面，而网站地图可以作为该页面的“准”内容。 生成步骤： 在hexo根目录下，运行以下指令安装站点地图生成的插件 Google 1npm install hexo-generator-sitemap --save Baidu 1npm install hexo-generator-baidu-sitemap --save 插件安装完毕后，每次运行hexo g会自动生成站点地图，位置在${hexo}\public文件夹下。 Google和Baidu分别生成sitemap.xml，baidusitemap.xml 在hexo配置文件_config.yml中，添加如下配置： 1234sitemap: path: sitemap.xmlbaidusitemap: path: baidusitemap.xml 运行hexo d进行部署，然后在浏览器访问你的域名/sitemap.xml，如果看到xml文件，那么就说明站点地图部署成功了。 创建robots.txtrobots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又称元数据）。具体实例可见这里。 在${hexo根目录}\source添加robots.txt，内容如下，可以根据需要自行修改拦截和允许通过等 12345678910111213# hexo robots.txtUser-agent: *Allow: /Allow: /archives/ Disallow: /js/Disallow: /css/Disallow: /fonts/Disallow: /vendors/Disallow: /fancybox/Sitemap: yourwebsiteurl/sitemap.xmlSitemap: yourwebsiteurl/baidusitemap.xml 当运行hexo d部署后，该文件就会在网站的根目录下，搜索引擎就可以根据该文件进行爬取。 数据统计与分析使用搜索网站提供的数据分析服务可以直观的了解网站的各种运行数据，这里介绍两种常用的分析工具。 Google Analysis 登录 Google Analysis，获得Google跟踪ID。 编辑 主题配置文件， 修改字段 google_analytics， 值设置成你的 Google 跟踪 ID。跟踪 ID 通常是以 UA- 开头。 百度统计 登录 百度统计，定位到站点的代码获取页面 复制 hm.js? 后面那串统计脚本 id，如下图所示： 123456789&lt;script&gt;var _hmt = _hmt || [];(function() &#123; var hm = document.createElement(&quot;script&quot;); hm.src = &quot;https://hm.baidu.com/hm.js?你的统计id&quot;; var s = document.getElementsByTagName(&quot;script&quot;)[0]; s.parentNode.insertBefore(hm, s);&#125;)();&lt;/script&gt; 编辑 主题配置文件， 修改字段 baidu_analytics，值设置成你的百度统计脚本 id。 使用CloudFlare在百度进行HTTPS认证时，出现如下提示： 解决方法：在www.cloudflare.com中注册账号，根据官网提示进行相关配置 1. 更改域名服务商的Name Servers将你的域名服务商的域名服务器改为cloudflare提供的两个，如下图 2. page rules设置等待域名服务商的域名服务器更新生效，dashboard的overview出现下图所示表示应用成功 然后在dashboard的page rules选项卡中进行如下配置 3. HSTS设置 该段转自https://molunerfinn.com/hexo-travisci-https 我们访问自己的网站是走HTTP-&gt;301/307重定向-&gt;HTTPS。这个是浏览器跟服务器进行了一次通信之后才发生的跳转。那有没有可能做到，访问的是HTTP，但是浏览器识别之后自动转成HTTPS访问，而不经过重定向那一层操作呢？答案是有的。通过HSTS的Preload List。 可以参考这篇文章对HSTS进行更深入的了解。简单来说，HSTS能够使我们的网站安全性更上一层楼。 CloudFare自带HSTS功能，开启之后就能很好的满足我们的需要。 在Crypto选项下，开启HSTS，配置如下： 然后可以去HSTS Preload List的网站把我们的域名进行检查并收录（不能是子域名，必须是一级域名），如果没通过会给出修改建议，按照建议修改就行。如果通过了，就会放入审核列表。之后可以时不时回来看看自己的网站被收录了没有。网上的说法普遍是几周内。所以耐心等待收录。一旦被收录就会应用到主流浏览器上，这样你的网站就更加安全。 我在第一次提交时出现如下问题，大意是http://wuleshen.com需要直接定向到https://wuleshen.com,而现在是先定向到https://www.wuleshen.com这个子域 HSTS Preload List 配置 .htaccess概述来说，htaccess文件是Apache服务器中的一个配置文件，它负责相关目录下的网页配置。通过htaccess文件，可以帮我们实现：网页301重定向、自定义404错误页面、改变文件扩展名、允许/阻止特定的用户或者目录的访问、禁止目录列表、配置默认文档等功能。当然最多的还是rewrite功能，即URL重写，PHP中实现伪静态的一个重要途径，也是被公认为SEO中搜索引擎友好的极为有效的一个手段。 首先，在${hexo根目录}\source下生成.htaccess，可以用touch .htaccess命令 然后，可以通过这个网站进行快速生成.htaccess，将内容复制到.htaccess文件中 12345678&lt;Files ~ &quot;^.(htaccess|htpasswd)$&quot;&gt;deny from all&lt;/Files&gt;RewriteEngine onRewriteCond %&#123;HTTP_HOST&#125; ^(www\.wuleshen\.com)(:80)? [NC]RewriteRule ^(.*) https://wuleshen.com/$1 [R=301,L]Redirect permanent http://wuleshen.com https://wuleshen.comorder deny,allow 此外，要让该文件生效，需要在hexo配置文件_config.yml中添加以下内容： 12include: - .htaccess 最后，hexo d将文件部署。 参考 https://theme-next.iissnan.com/third-party-services.html#analytics-system https://molunerfinn.com/hexo-travisci-https]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>SEO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数字签名和数字证书]]></title>
    <url>%2F2019%2F02%2F13%2FdigitalSignature%2F</url>
    <content type="text"><![CDATA[密钥加密 A有一对成对的钥匙，一把为公钥，一把为私钥 公钥可以发送给别人，私钥只能自己保存 公钥私钥加密原理基于大质数分解 加密流程 A将自己的公钥发送给B 这时，B要发送信息给A，B利用A的公钥加密要发送的内容然后发给A A收到加密信息后利用自己的私钥解密 只要A的私钥不泄露，信息就是安全的，即使落在别人手里，也无法解密。 数字签名步骤1：生成摘要（MD5） A对信息使用hash函数（常用的MD5等）生成一个摘要（Digest） 步骤2：非对称加密（RSA1/2） A对这个摘要用私钥加密，生成数字签名（signature） A将数字签名附在要发送的信息后发送给B B对数字签名用公钥解密，得到信息的摘要 B对信息本身使用hash函数，将得到的结果和上一步的摘要进行比对，如果两者一致，则说明信息未被改动 如果这时，C用自己的公钥替换了A的公钥，那么C就可以冒充A，让B用C的公钥解密C发送的信息 因此，这里需要一个具有公信力的机构（证书中心 certificate authority，简称CA）为公钥进行认证，这时就引出数字证书 RSA加密算法区别 开放平台签名算法名称 标准签名算法名称 备注 RSA2 SHA256WithRSA 强制要求RSA密钥的长度至少为2048 RSA SHA1WithRSA 对RSA密钥的长度不限制，推荐使用2048位以上 数字证书 证书中心用自己的私钥，对A的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate） 简而言之，数字证书就是对公钥进行加密的 A今后发送加密信息时，除了附上数字签名外，再附上一个数字证书就可以保证自己的公钥不被冒充替换 实例：https协议 请求： 客户端向服务端发送加密请求 响应：服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。 参考 阮一峰的数字签名是什么]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>RSA</tag>
        <tag>数字签名</tag>
        <tag>数字证书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从浏览器输入URL到页面加载展示，中间发生了什么]]></title>
    <url>%2F2019%2F02%2F09%2Furl-to-webpage%2F</url>
    <content type="text"><![CDATA[这是一个面试中常会遇到的问题，其中涉及的问题很多，接下来会试着一一分析一下。 具体过程主要分为浏览器处理URL、DNS解析、获取TCP连接、发送HTTP请求、服务器处理请求、服务器返回响应、浏览器渲染页面这几大步骤。 本文以输入www.google.com 为例进行分析，浏览器以chrome为例。 浏览器处理URL1. 校验URL格式首先，浏览器会校验用户输入的URL格式是否正确，如果不是URL地址，那么浏览器会自动调用默认的搜索引擎进行搜索。 合法的URL地址如下 1&lt;scheme&gt;://&lt;user&gt;:&lt;password&gt;@&lt;host&gt;:&lt;port&gt;/&lt;path&gt;;&lt;params&gt;?&lt;query&gt;#&lt;frag&gt; URL 为了在不同协议不同传输机制都可以安全的运送信息，采用的字符都是符合 ASCII 集的。这其中还包含一些保留字符，比如上面的 URL 协议中的分割字符，等特殊含义的字符。而不安全的字符，非 ASCII 的 Unicode（中文等）字符，就会通过转义去处理，使用% 。 此部分就是检查 url 的合法性，并对不合法的进行转义。浏览器还会检查 HSTS 列表。 2. 检查HSTS 列表HSTS 就是一种安全策略的机制，是为了让浏览器强制使用 HTTPS 访问的，详细可以去这篇文章看，介绍的比较清楚。当你的网站均采用 HTTPS，并符合它的安全规范，就可以申请加入 HSTS 列表，之后用户不加 HTTPS 协议再去访问你的网站，浏览器都会定向到 HTTPS。 例如用户输入google.com ，最终会定向到https://www.google.com/。 DNS解析我们浏览器中输入的地址只是一个代号，服务器是不认识这个名称的，服务器需要IP地址来进行定位。 通过DNS（Domain Name System）域名系统解析，我们可以把url转换为IP地址 1. 查询缓存1.1 查看浏览器内部缓存检测域名是否存在于浏览器缓存中，如果有缓存直接使用，没有则下一步。打开 chrome://net-internals/#dns 即可查看本机浏览器的 dns 缓存。（chrome中有效期为1分钟） 1.2 系统缓存浏览器会调用一个库函数，此函数会先去检测本地 hosts文件，查看是否有对应ip。 1.3. 路由器缓存、ISP 缓存如果浏览器和系统缓存都没有，系统的库函数就会像 DNS 服务器发送请求。而网络服务一般都会先经过路由器以及网络服务商（电信），所以会先查询路由器缓存，然后再查询 ISP 的 DNS 缓存。 2. 本地 DNS 服务器windows下利用ipconfig命令可以查看本机DNS服务器地址 3. 域名服务器如果本机DNS没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到google的IP地址并把它缓存到本地，供下次查询使用。 关于根域名服务器的介绍以及为什么是13台，可以去这篇文章 看，讲的很明白。 到此处的过程为：根域服务器（.） -&gt; 顶级域名服务器（.com）-&gt; 主域名服务器（google.com） 经过以上这些查询，如果域名正常，在某一步骤应该就会返回 IP 地址，如果直到最后一步都没有查询到，浏览器就会提示找不到服务器地址。 得到目标服务器地址后，可以进行TCP连接了。 TCP连接TCP协议（Transmission Control Protocol，传输控制协议）是一种面向连接，确保数据在端到端之间可靠传输的协议。由于TCP协议十分复杂，这里仅作简单介绍。 TCP header 根据TCP/IP协议，需要本机和目标服务器的ip和port才能进行传输。 本机ip：由操作系统分配 本机port：由操作系统分配 目标服务器ip：通过DNS解析 目标服务器port：http协议默认80，https协议默认443 建立TCP连接TCP有6个标志位，分别为SYN, ACK, FIN, URG, PSH, RST。置一有效。 这里介绍SYN，ACK， FIN这3个标志位。 SYN（Synchronize Sequence Number）: 建立连接的同步信号 ACK（Acknowledgement）: 对收到的数据进行确认 FIN（Finish）: 表示后面没有数据要发送，连接需要关闭 还需要用到两个序号，序列号seq和确认序号ack seq（sequence number）：表示要发送的数据的第一个字节的序号，后面按这个逻辑递增 ack（Acknowledgement number）：期望收到的下一个报文段数据的第一个字节的序号 3次握手的过程如下图所示 为什么要三次挥手来建立连接？ 主要是要初始化Sequence Number(seq) 的初始值。seq要作为以后的数据通信的序号，以保证应用层接收到的数据不会因为网络上的传输的问题而乱序（TCP会用这个序号来拼接数据）。 为什么是三次而不是两次？ 主要因为信息对等和防止超时 信息对等：如果只进行2次握手，B机器无法确认A收到了自己的信息，只有通过第3次握手，才能确认自己的发报能力和收报能力都是正常的 防止超时：TTL网络报文的生存时间往往都会超过TCP请求超时时间，如果只用2次握手建立连接，那么当A机器发送第一个请求超时，第二个请求才和B机器建立连接，当A发送的第一 个超时请求这个时候才到达B时，B机器会建立一个新的连接，然而，由于A的状态不是SYN_SENT，会直接丢弃B的确认数据，导致B单方面创建连接完毕。 断开TCP连接建立连接需要3次，而断开连接需要4次挥手。主要过程见下图。 这里主要介绍一下CLOSE_WAIT和TIME_WAIT这两个状态。 CLOSE_WAIT: 该状态表示等待关闭，并通知应用程序发送剩余数据，处理现场信息，关闭相关资源。 TIME_WAIT: 主动要求关闭的机器在收到对方的FIN报文后，发送ACK报文，并进入TIME_WAIT状态，等待2MSL后即可进入CLOSED关闭状态。 MSL(Maximum Segment Lifetime)，等待2MSL是报文在网络上生存的最长时间，超过阈值报文则被丢弃，一般来说MSL大于TTL衰减至0的时间。在RFC793中规定MSL为2分钟，然而在当前告诉网络中，2分钟等待时间会造成极大的资源浪费，在高并发服务器上通常会使用更小的值。 既然TIME_WAIT这个状态看起很鸡肋，为何不直接进入CLOSED状态呢？ 主要有两点原因： 第一，确认被动关闭方能够顺利进入CLOSED状态。如果最后一个ACK没有到达B机器，B机器会重发FIN+ACK报文，当A机器收到了第二次FIN+ACK报文，会重发一次ACK，并重新计时。如果A没有等待时间而是发送完ACK后直接关闭，可能会导致B机器无法确保收到最后的ACK指令。 第二，防止失效请求。防止已失效连接的请求数据包与正常连接的请求数据包混淆而发生异常。 RFC793定义了MSL为2分钟，Linux设置成了30s，在服务器上通过变更/etc/sysctl.conf文件修改 1net.ipv4.tcp_fin_timeout = 30 服务器上TIME_WAIT状态过多的原因？ 如果在大并发的短链接下，此状态可能过多，可通过优化服务器参数得到解决vim /etc/sysctl.conf编辑文件，选择添加以下内容： 1234net.ipv4.tcp_syncookies = 1net.ipv4.tcp_tw_reuse = 1net.ipv4.tcp_tw_recycle = 1net.ipv4.tcp_fin_timeout = 30 然后执行 /sbin/sysctl -p让参数生效。 net.ipv4.tcp_syncookies = 1 表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击。请注意，请先千万别用tcp_syncookies来处理正常的大负载的连接的情况。因为，syncookies是妥协版的TCP协议，并不严谨。默认为0，表示关闭；net.ipv4.tcp_tw_reuse = 1表示开启重用。官方文档上说tcp_tw_reuse 加上tcp_timestamps（又叫PAWS, for Protection Against Wrapped Sequence Numbers）可以保证协议的角度上的安全，但是你需要tcp_timestamps在两边都被打开（你可以读一下tcp_twsk_unique的源码 ）。默认为0，表示关闭；net.ipv4.tcp_tw_recycle = 1 表示开启TCP连接中TIME-WAIT sockets的快速回收。如果是tcp_tw_recycle被打开了话，会假设对端开启了tcp_timestamps，然后会去比较时间戳，如果时间戳变大了，就可以重用。但是，如果对端是一个NAT网络的话（如：一个公司只用一个IP出公网）或是对端的IP被另一台重用了，这个事就复杂了。建连接的SYN可能就被直接丢掉了（你可能会看到connection time out的错误）。默认为0，表示关闭。使用tcp_tw_reuse和tcp_tw_recycle来解决TIME_WAIT的问题是非常非常危险的，因为这两个参数违反了TCP协议（RFC 1122) 服务器上CLOSE_WAIT状态过多的原因？ 对方关闭socket连接，我方忙于读或写，没有及时关闭连接。 检查代码，特别是释放资源的代码 检查配置，特别是处理请求的线程配置 1234# 查看443端口上CLOSE_WAIT状态的命令netstat -ant | grep -i "443" | grep CLOSE_WAIT | wc-1# 统计各个状态的连接数netstat -n | awk '/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;' 为什么需要四次挥手才能断开连接？ 因为TCP建立的是全双工连接，发送方和接收方都需要FIN报文和ACK报文。 TCP滑动窗口The TCP/IP Guide中有详细的解说 TCP对于发送数据进行跟踪，这种数据管理需要协议有以下两大关键功能： 可靠性：保证数据确实到达目的地。如果未到达，能够发现并重传。 数据流控：管理数据的发送速率，以使接收设备不致于过载。 要完成这些任务，整个协议操作是围绕滑动窗口确认机制来进行的。因此，理解了滑动窗口，也就是理解了TCP。 发送方的滑动窗口示意图 图中分为4个部分，其中黑色方框框出的部分就是滑动窗口 1. 已发送已确认 数据流中最早的字节已经发送并得到确认。这些数据是站在发送设备的角度来看的。如上图所示，31个字节已经发送并确认。 2. 已发送但尚未确认 已发送但尚未得到确认的字节。发送方在确认之前，不认为这些数据已经被处理。上图所示14字节为第2类。 3. 未发送而接收方已Ready 设备尚未将数据发出，但接收方根据最近一次关于发送方一次要发送多少字节确认自己有足够空间。发送方会立即尝试发送。如图，第3类有6字节。 4. 未发送而接收方Not Ready 由于接收方not ready，还不允许将这部分数据发出。 滑动后窗口示意图 当发送方接收到一系列字节的确认时，它知道数据被接收方成功地接收了，发送方将这些数据从“已发送但未确认”移动到“已发送已确认”。这样使得滑动窗口向右滑动，允许发送发发送更多数据。 发送HTTPS请求TCP连接建立后，客户端向浏览器发送HTTP请求。 现在很多网站都使用https协议替代了http协议。 HTTPS全称为HTTP over SSL。其中，SSL（Secure Socket Layer）安全套接字层，是一个工作于应用层和传输层之间，为应用提供加密传输的协议。顾名思义，HTTPS就是在HTTP上增加了SSL协议的加密能力。 关于数字加密这里需要补充一点数字加密的相关知识，在另一篇文章中提及。 HTTPS建立连接HTTPS建立连接步骤大致如下： 客户端向服务端发送请求，客户端会告诉服务端自己支持哪些加密套件 服务端收到请求后，会返回一系列协议数据，并以一个没有数据内容的Server Hello Done 作为结束。 客户端在收到服务端的握手信息后，也会发送一系列协议。 服务端在接收客户端的确认信息和验证信息后，会对客户端发送的数据进行确认。 最后，如果双方都确认加密无误后，各自按照之前约定的Session Secret对应用数据进行加密传输。 具体的协议数据等，可以通过抓包工具进行查看，这里就不做展开了。 服务器处理请求WEB服务器如果后端采用WEB服务器和应用服务器的架构，请求先到达WEB服务器，然后在由WEB服务器转发到某个应用服务器。 常见的WEB服务器有Nginx Nginx利用epoll的方式读取请求，判断请求类型。 对于静态请求：读取服务器硬盘上的相关文件，直接返回 对于动态请求：转发到应用服务器（这里假设为Tomcat），如果有多个应用服务器，需要采用策略（负载均衡） 应用服务器常用的应用服务器有Tomcat Tomcat是一个由Java编写的可以运行Servlet/JSP的容器，Javaweb的代码运行在这个容器上 Tomcat会采用阻塞I/O(Blocking I/O)或者I/O多路复用技术(NIO) BIO: 为每个请求分配一个线程去处理 NIO: 监听所有的连接，当连接状态发生变化，才用一个线程/进程对那个连接进行处理，处理完继续监视 服务器返回响应Http请求到达应用服务器后，会被交给某个Servlet处理。 如果使用框架（SpringMVC），DispatcherServlet会处理收到的请求。经过处理器映射器，处理器适配器交给Controller执行，返回的模型视图（ModelAndView）对象会交给视图解析器（ViewResolver） 浏览器渲染页面视图解析器内部调用render方法，将Model数据填充到View中，最终将View包装成Response传给浏览器。 浏览器从HTTPResponse中读取数据，准备显示页面。 由于HTML中可能引用大量其他资源，例如js，css，图片等，浏览器会下载这些资源（从DNS获取IP地址开始） 当服务器发给客户端资源文件时，会告知何时过期（使用Cache-control或者Expire），客户端可以把文件缓存到本地，下次再有请求时，如果没有过期，可以直接从本地缓存读取。如果过期，客户端会询问服务器资源是否被修改（依据上一次服务器发送的Last-Modified），如果未被修改（状态码304 Not Modified），可以继续使用缓存，否则服务器会发送最新的资源到客户端。 参考 https://github.com/sunyongjian/blog/issues/34 https://segmentfault.com/a/1190000006879700 https://www.cnblogs.com/crazylqy/p/7110357.html https://www.cnblogs.com/derekchen/archive/2011/02/26/1965839.html 《码出高效 Java开发手册》]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Web</tag>
        <tag>计算机网络</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对接支付宝支付功能（三）异步通知]]></title>
    <url>%2F2019%2F02%2F03%2Fjava-alipay-1%2F</url>
    <content type="text"><![CDATA[支付宝回调异步通知当面付异步通知 当商户调用预下单请求API生成二维码展示给用户后，用户通过手机扫描二维码进行支付，支付宝会将该笔订单的变更信息，沿着商户调用预下单请求时所传入的通知地址主动推送给商户。 通知触发条件：交易状态为TRADE_SUCCESS 服务器异步通知页面特性 必须保证服务器异步通知页面（notify_url）上无任何字符，如空格、HTML标签、开发系统自带抛出的异常提示信息等； 支付宝是用POST方式发送通知信息，因此该页面中获取参数的方式，如：request.Form(“out_trade_no”)、$_POST[‘out_trade_no’]； 支付宝主动发起通知，该方式才会被启用； 只有在支付宝的交易管理中存在该笔交易，且发生了交易状态的改变，支付宝才会通过该方式发起服务器通知（即时到账中交易状态为“等待买家付款”的状态默认是不会发送通知的）； 服务器间的交互，不像页面跳转同步通知可以在页面上显示出来，这种交互方式是不可见的； 第一次交易状态改变（即时到账中此时交易状态是交易完成）时，不仅会返回同步处理结果，而且服务器异步通知页面也会收到支付宝发来的处理结果通知； 程序执行完后必须打印输出“success”（不包含引号）。如果商户反馈给支付宝的字符不是success这7个字符，支付宝服务器会不断重发通知，直到超过24小时22分钟。一般情况下，25小时以内完成8次通知（通知的间隔频率一般是：4m,10m,10m,1h,2h,6h,15h）； 程序执行完成后，该页面不能执行页面跳转。（不能有重定向）如果执行页面跳转，支付宝会收不到success字符，会被支付宝服务器判定为该页面程序运行出现异常，而重发处理结果通知； cookies、session等在此页面会失效，即无法获取这些数据； 该方式的调试与运行必须在服务器上，即互联网上能访问；（如果本地调试，需要使用内网穿透） 该方式的作用主要防止订单丢失，即页面跳转同步通知没有处理订单更新，它则去处理； 当商户收到服务器异步通知并打印出success时，服务器异步通知参数notify_id才会失效。也就是说在支付宝发送同一条异步通知时（包含商户并未成功打印出success导致支付宝重发数次通知），服务器异步通知参数notify_id是不变的。 异步返回结果的验签实例：某商户设置的通知地址为https://api.xx.com/receive_notify.htm，对应接收到通知的示例如下： 12345678910111213https://api.xx.com/receive_notify.htm?gmt_payment=2015-06-11 22:33:59&amp;notify_id=42af7baacd1d3746cf7b56752b91edcj34&amp;seller_email=testyufabu07@alipay.com&amp;notify_type=trade_status_sync&amp;sign=kPbQIjX+xQc8F0/A6/AocELIjhhZnGbcBN6G4MM/HmfWL4ZiHM6fWl5NQhzXJusaklZ1LFuMo+lHQUELAYeugH8LYFvxnNajOvZhuxNFbN2LhF0l/KL8ANtj8oyPM4NN7Qft2kWJTDJUpQOzCzNnV9hDxh5AaT9FPqRS6ZKxnzM=&amp;trade_no=2015061121001004400068549373&amp;out_trade_no=21repl2ac2eOutTradeNo322&amp;gmt_create=2015-06-11 22:33:46&amp;seller_id=2088211521646673&amp;notify_time=2015-06-11 22:34:03&amp;subject=FACE_TO_FACE_PAYMENT_PRECREATE中文&amp;trade_status=TRADE_SUCCESS&amp;sign_type=RSA2 第一步： 在通知返回参数列表中，除去sign、sign_type两个参数外，凡是通知返回回来的参数皆是待验签的参数。 1234567891011121314151617181920212223logger.debug("**********************支付宝回调开始**********************"); // 得到并遍历回调传来的参数Map&lt;String, String[]&gt; requestParams = request.getParameterMap();Map&lt;String, String&gt; params = new HashMap&lt;&gt;();// 将前台的参数转换为"xxx"-&gt;"aaa,bbb"的格式存入params中,实际上回调传来的参数每个key都只对应一个valuefor (Map.Entry&lt;String, String[]&gt; entry: requestParams.entrySet()) &#123; String key = entry.getKey(); String values[] = entry.getValue(); StringBuilder valStr = new StringBuilder(); for (int i = 0; i &lt; values.length; i ++) &#123; if ( i != values.length - 1) &#123; valStr.append(values[i]).append(","); &#125; else &#123; valStr.append(values[i]); &#125; &#125; params.put(key, valStr.toString());&#125;// 日志打印回调信息，包括签名，支付状态，所有参数logger.info("alipay_callback, sign:&#123;&#125;, trade_status:&#123;&#125;, params:&#123;&#125;", params.get("sign"), params.get("trade_status"),params.toString());// 需要除去sign、sign_type两个参数，而sign已经在#rsaCheckV2方法中除去了params.remove("sign_type"); 第二步： 将剩下参数进行url_decode, 然后进行字典排序，组成字符串，得到待签名字符串 第三步： 将签名参数（sign）使用base64解码为字节码串。 ​ 第二步和第三步在支付宝提供的rsaCheckV2方法中已经实现 第四步： 使用RSA的验签方法，通过签名字符串、签名参数（经过base64解码）及支付宝公钥验证签名。 12345678910try &#123; // 使用RSA的验签方法，通过签名字符串、签名参数（经过base64解码）及支付宝公钥验证签名 boolean rsaCheckV2 = AlipaySignature.rsaCheckV2(params, Configs.getAlipayPublicKey(), "utf-8", Configs.getSignType()); // 验签失败 if ( !rsaCheckV2 ) &#123; return ServerResponse.createByErrorMessage("验签失败，检测到非法请求"); &#125;&#125; catch (AlipayApiException e) &#123; logger.error("支付宝回调异常");&#125; 需要注意的是rsaCheckV2有两个重载的方法，一个是带signType参数的，我们需要使用这个方法指定签名类型为RSA2（可以从之前装配的Configs类直接获取），而不带signType的方法默认使用SHA1WithRSA的类型 12345678910111213141516171819202122232425262728293031323334353637383940// 支付宝提供的验签方法，内部已经实现了除去sign参数、字典排序成待签名字符串、将sign使用base64解码为字节码串public static boolean rsaCheckV2(Map&lt;String, String&gt; params, String publicKey, String charset,String signType) throws AlipayApiException &#123; String sign = params.get("sign"); String content = getSignCheckContentV2(params); return rsaCheck(content, sign, publicKey, charset,signType);&#125;public static String getSignCheckContentV2(Map&lt;String, String&gt; params) &#123; if (params == null) &#123; return null; &#125; params.remove("sign"); StringBuffer content = new StringBuffer(); List&lt;String&gt; keys = new ArrayList&lt;String&gt;(params.keySet()); Collections.sort(keys); for (int i = 0; i &lt; keys.size(); i++) &#123; String key = keys.get(i); String value = params.get(key); content.append((i == 0 ? "" : "&amp;") + key + "=" + value); &#125; return content.toString();&#125;public static boolean rsaCheck(String content, String sign, String publicKey, String charset, String signType) throws AlipayApiException &#123; if (AlipayConstants.SIGN_TYPE_RSA.equals(signType)) &#123; return rsaCheckContent(content, sign, publicKey, charset); // 这里使用的是RSA2的签名方法 &#125; else if (AlipayConstants.SIGN_TYPE_RSA2.equals(signType)) &#123; return rsa256CheckContent(content, sign, publicKey, charset); &#125; else &#123; throw new AlipayApiException("Sign Type is Not Support : signType=" + signType); &#125;&#125; 第五步：需要严格按照如下描述校验通知数据的正确性。 商户需要验证该通知数据中的out_trade_no是否为商户系统中创建的订单号，并判断total_amount是否确实为该订单的实际金额（即商户订单创建时的金额），同时需要校验通知中的seller_id（或者seller_email) 是否为out_trade_no这笔单据的对应的操作方（有的时候，一个商户可能有多个seller_id/seller_email），上述有任何一个验证不通过，则表明本次通知是异常通知，务必忽略。在上述验证通过后商户必须根据支付宝不同类型的业务通知，正确的进行不同的业务处理，并且过滤重复的通知结果数据。在支付宝的业务通知中，只有交易通知状态为TRADE_SUCCESS或TRADE_FINISHED时，支付宝才会认定为买家付款成功。 注意： 状态TRADE_SUCCESS的通知触发条件是商户签约的产品支持退款功能的前提下，买家付款成功； 交易状态TRADE_FINISHED的通知触发条件是商户签约的产品不支持退款功能的前提下，买家付款成功；或者，商户签约的产品支持退款功能的前提下，交易已经成功并且已经超过可退款期限。 1234567// 商户需要校验通知数据的正确性ServerResponse serverResponse = iOrderService.alipayCallback(params);// 校验成功，一定要打印出“success”if (serverResponse.isSuccuess()) &#123;return Const.AlipayCallback.RESPONSE_SUCCESS;&#125;return Const.AlipayCallback.RESPONSE_FAILED; 商户需要依次校验通知数据的正确性 12345678910111213141516171819202122232425262728public ServerResponse alipayCallback(Map&lt;String, String&gt; params) &#123; // 支付宝外部订单号，也就是商城订单号 Long orderNo = Long.valueOf(params.get("out_trade_no")); logger.debug("out_trade_no: &#123;&#125;", orderNo.toString()); // 支付宝交易号 String tradeNo = params.get("trade_no"); // 交易状态 String tradeStatus = params.get("trade_status"); logger.debug("trade_status: &#123;&#125;", tradeStatus); Order order = orderMapper.selectByOrderNo(orderNo); if (order == null) &#123; return ServerResponse.createByErrorMessage("不是该商城订单，忽略回调"); &#125; // 判断交易状态 // 交易状态为已付款，已发货，订单完成，订单关闭时，为重复调用 if (order.getStatus() &gt;= Const.OrderStatusEnum.PAID.getCode()) &#123; return ServerResponse.createBySuccess("支付宝重复调用"); &#125; // 交易成功，记录付款时间，更新订单状态为已付款 if (Const.AlipayCallback.TRADE_STATUS_TRADE_SUCCESS.equals(tradeStatus)) &#123; order.setPaymentTime(DateTimeUtil.strToDate(params.get("gmt_payment"))); order.setStatus(Const.OrderStatusEnum.PAID.getCode()); orderMapper.updateByPrimaryKeySelective(order); &#125; // 组装支付信息对象，略 ... return ServerResponse.createBySuccess();&#125; 回调出错的排查如果回调出现问题，支付宝提供了一些自查方案可以先自行排查 收不到异步通知自查方案-支付宝接口常见错误系列 收不到异步通知「自检方案」 需http://或者https://格式的完整路径 例：https://您的域名/notify_url.php ，支持ip地址方式。（推荐使用域名） 不能加?id=123这类自定义参数 错误示例：https://您的域名/notify_url.php？id=123&amp;test=abc 必须外网可以正常访问，这个不难理解，在您的异步地址没有代码逻辑的情况下，直接访问应该是一个空白 页面并且http状态是200（不支持http200以外的状态） 不能有重定向 如：http302 使用POST方式接收，请确保服务器路由已经开放POST通知]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对接支付宝功能（二）当面付预下单]]></title>
    <url>%2F2019%2F02%2F01%2Fjava-alipay-2%2F</url>
    <content type="text"><![CDATA[当面付预下单支付流程接入指引 官方文档提供了接入的详细指引，调用流程和注意事项的介绍 这里放一张支付流程 加载alipay SDK jar包首先，需要在项目中添加alipay-sdk-java和alipay-trade-sdk这两个包 将本地jar包通过maven发布到服务器上 为了读取在“/src/main/webapp/WEB-INF/lib”路径下的jar包，在pom文件中添加maven插件的配置 12345678910111213&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;1.8&lt;/source&gt; &lt;target&gt;1.8&lt;/target&gt; &lt;encoding&gt;UTF-8&lt;/encoding&gt; &lt;compilerArguments&gt; &lt;extdirs&gt;$&#123;project.basedir&#125;/src/main/webapp/WEB-INF/lib&lt;/extdirs&gt; &lt;/compilerArguments&gt; &lt;/configuration&gt; &lt;/plugin&gt;&lt;/plugins&gt; 支付宝生成二维码核心代码修改自com.alipay.demo.trade.Main支付宝官方demo 1. 设置支付相关参数 外部订单号，订单标题，总金额，不可打折金额，卖家支付宝账号ID，订单描述，商户操作员编号，商户门店编号，业务扩展参数，支付超时，商品明细列表等参数 1outTradeNo, subject, totalAmount, undiscountableAmount, sellerId, body, operatorId, storeId, extendParams, timeoutExpress, goodsDetailList 2. 创建扫码支付请求builder，将上述参数通过调用链进行设置 ​ 这里需要注意notifyUrl字段，支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 123AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder().setXXX(aaa).setYYY(bbb) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))// alipay.callback.url=希望回调通知的地址 3. 初始化tradeService 从配置文件读取支付宝网关名，appId，商户私钥，格式（json），字符集（utf-8），支付宝公钥，签名类型等信息 这里用到了com.alipay.demo.trade包中的Configs和AlipayTradeServiceImpl来生成tradeService 123456789101112private AlipayTradeServiceImpl init_tradeService() &#123; /** 一定要在创建AlipayTradeService之前调用Configs.init()设置默认参数 * Configs会读取classpath下的zfbinfo.properties文件配置信息，如果找不到该文件则确认该文件是 * 否在classpath目录 */ Configs.init("alipayinfo.properties"); /** 使用Configs提供的默认参数 * AlipayTradeService可以使用单例或者为静态成员对象，不需要反复new */ tradeService = new AlipayTradeServiceImpl.ClientBuilder().build(); return tradeService;&#125; 4. 当面付预下单 调用预下单方法，传入之前生成的builder对象，tradePrecreate内部会调用AlipayClient的execute方法，进行远程调用，返回一个response对象 1AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); 5.判断下单是否成功 5.1 预下单成功，生成二维码到指定路径 12345678910111213141516171819202122232425262728293031private void trade_precreate_success(AlipayF2FPrecreateResult result, String path) &#123; // 简单打印应答 AlipayTradePrecreateResponse response = result.getResponse(); dumpResponse(response); // 本地生成二维码存放文件夹 File folder = new File(path); if (!folder.exists()) &#123; folder.setWritable(true); folder.mkdirs(); &#125; /* 生成二维码流程 1. 根据外部订单号（outTradeNo）生成二维码存放路径（qrPath） 2. 生成二维码到qrPath */ String qrPath = String.format(path + "/qr-%s.png", response.getOutTradeNo()); String qrFileName = String.format("qr-%s.png", response.getOutTradeNo()); // 生成二维码图片到本地指定路径 File imageFile = ZxingUtils.getQRCodeImge(response.getQrCode(), 256, qrPath); try &#123; // 将本地路径的二维码图片上传到ftp服务器 FTPUtil.uploadFile(Lists.newArrayList(imageFile)); &#125; catch (IOException e) &#123; logger.error("上传二维码异常", e); &#125; logger.info("qrPath:" + qrPath); // 生成二维码的ftp Url String qrUrl = PropertiesUtil.getProperty("ftp.server.http.prefix") + imageFile.getName(); resultMap.put("qrUrl", qrUrl);&#125; 流程总结整理 1234567891011121314151617181920212223242526272829303132333435363738394041&#123; // 1. 设置支付相关参数，具体可以参考demo中的说明 outTradeNo, subject, totalAmount, undiscountableAmount, sellerId, body, operatorId, storeId, extendParams, timeoutExpress, goodsDetailList // 2. 创建扫码支付请求builder，设置请求参数 AlipayTradePrecreateRequestBuilder builder = new AlipayTradePrecreateRequestBuilder() .setSubject(subject).setTotalAmount(totalAmount).setOutTradeNo(outTradeNo) .setUndiscountableAmount(undiscountableAmount).setSellerId(sellerId).setBody(body) .setOperatorId(operatorId).setStoreId(storeId).setExtendParams(extendParams) .setTimeoutExpress(timeoutExpress) .setNotifyUrl(PropertiesUtil.getProperty("alipay.callback.url"))//支付宝服务器主动通知商户服务器里指定的页面http路径,根据需要设置 .setGoodsDetailList(goodsDetailList); // 3. 初始化tradeService tradeService = init_tradeService(); // 4. 当面付预下单 AlipayF2FPrecreateResult result = tradeService.tradePrecreate(builder); // 5. 根据下单返回结果进行后续处理 switch (result.getTradeStatus()) &#123; case SUCCESS: logger.info("支付宝预下单成功: )"); // 5.1 预下单成功，生成二维码到指定路径 trade_precreate_success(result, path); return ServerResponse.createBySuccess(resultMap); case FAILED: logger.error("支付宝预下单失败!!!"); return ServerResponse.createByErrorMessage("支付宝预下单失败!!!"); case UNKNOWN: logger.error("系统异常，预下单状态未知!!!"); return ServerResponse.createByErrorMessage("系统异常，预下单状态未知!!!"); default: logger.error("不支持的交易状态，交易返回异常!!!"); return ServerResponse.createByErrorMessage("不支持的交易状态，交易返回异常!!!"); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java对接支付宝支付功能（一）官方Demo调试]]></title>
    <url>%2F2019%2F01%2F22%2Fjava-alipay-3%2F</url>
    <content type="text"><![CDATA[支付宝当面付官方Demo调试配置沙箱环境官方文档 点击“开放平台-开发者中心-沙箱环境”。进入沙箱环境页面，系统已经自动为你创建一个应用，在基础信息中可以看到应用信息。 生成并上传RSA2(SHA256)的应用公钥，详见生成RSA密钥；配置RSA2(SHA256)的应用公钥后，不需要配置RSA(SHA1)密钥，RSA和RSA2签名算法区别可以参考此处； 编写代码时，请将 ​ a.请求网关修改为：https://openapi.alipaydev.com/gateway.do ​ b.appid切换为沙箱的appid ​ c.签名方式使用RSA2 ​ d.应用私钥使用第1步生成的RSA2(SHA256)的私钥(请根据开发语言进行选择原始或pkcs8格式) ​ e.支付宝公钥切换为第1步配置后应用公钥后，点击查看支付宝公钥看到的公钥 当面付demo演示 下载demo，地址：https://docs.open.alipay.com/194/105201/ 将demo导入idea 配置支付相关的属性alipayinfo.properties 12345678910111213141516171819202122232425262728# 支付宝网关名、partnerId和appIdopen_api_domain = https://openapi.alipaydev.com/gateway.domcloud_api_domain = http://mcloudmonitor.com/gateway.dopid = 你的pidappid = 你的appid# RSA秘钥生成具体见官方文档# 应用私钥公钥private_key = 应用公钥public_key = 应用私钥#SHA1withRsa对应支付宝公钥#alipay_public_key = 使用RSA2时，不用配置此项#SHA256withRsa对应支付宝公钥alipay_public_key = 支付宝公钥# 签名类型: RSA-&gt;SHA1withRsa,RSA2-&gt;SHA256withRsasign_type = RSA2# 当面付最大查询次数和查询间隔（毫秒）max_query_retry = 5query_duration = 5000# 当面付最大撤销次数和撤销间隔（毫秒）max_cancel_retry = 3cancel_duration = 2000# 交易保障线程第一次调度延迟和调度间隔（秒）heartbeat_delay = 5heartbeat_duration = 900 启动main方法 运行结果 1234567891011121314151617181920212223242526272829303132一月 22, 2019 10:58:54 下午 com.alipay.demo.trade.config.Configs init信息: 配置文件名: alipayinfo.properties一月 22, 2019 10:58:54 下午 com.alipay.demo.trade.config.Configs init信息: Configs&#123;支付宝openapi网关: https://openapi.alipaydev.com/gateway.do, 支付宝mcloudapi网关域名: http://mcloudmonitor.com/gateway.do, pid: 2088102177123264, appid: 2016092400588794, 商户RSA私钥: MIIEvg******g1jt2A, 商户RSA公钥: MIIBIj******IDAQAB, 支付宝RSA公钥: MIIBIj******IDAQAB, 签名类型: RSA2, 查询重试次数: 5, 查询间隔(毫秒): 5000, 撤销尝试次数: 3, 撤销重试间隔(毫秒): 2000, 交易保障调度延迟(秒): 5, 交易保障调度间隔(秒): 900&#125;一月 22, 2019 10:58:54 下午 com.alipay.demo.trade.service.impl.AbsAlipayTradeService tradePrecreate信息: trade.precreate bizContent:&#123;"out_trade_no":"tradeprecreate15481691348134324306","seller_id":"","total_amount":"0.01","undiscountable_amount":"0","subject":"xxx品牌xxx门店当面付扫码消费","body":"购买商品3件共20.00元","goods_detail":[&#123;"goods_id":"goods_id001","goods_name":"xxx小面包","quantity":1,"price":"10"&#125;,&#123;"goods_id":"goods_id002","goods_name":"xxx牙刷","quantity":2,"price":"5"&#125;],"operator_id":"test_operator_id","store_id":"test_store_id","extend_params":&#123;"sys_service_provider_id":"2088100200300400500"&#125;,"timeout_express":"120m"&#125;一月 22, 2019 10:58:56 下午 com.alipay.api.internal.util.AlipayLogger logBizSummary信息: Summary^_^10000^_^null^_^ProtocalMustParams:charset=utf-8&amp;method=alipay.trade.precreate&amp;sign=eT6bgbDSF33TeESmRaqWCzfKZ5FB23e4ul6IOdPR9y1Lk6fKEWAhIWW/H0PWt4ttzsyhazy/HnoP4rSNBA11MW6FkK7EA7bwvU+V/kuDEMer4mbq9bPZ44zq5XHUW2wWxrGEIXWGa0O2UwFg1ahWDJCeXGUYqndOFtgMLeuKsShEZ7l/6t9xfMEQSUyfzutucqgGGBApA3YNRpxa7Dh0zD1PZw0yqe0qDpEp2mbNvOEYWilaLS1wtHwOaOzNYKXJ+9xfrz1YMjh6R0ikbIRGdKxPuTLiRB7F8pLim/QwvZYC/n0O9tmIF1X7CrN44Vimhy23IY3VEWbjuGKD4jvM8Q==&amp;version=1.0&amp;app_id=2016092400588794&amp;sign_type=RSA2&amp;timestamp=2019-01-22 22:58:54^_^ProtocalOptParams:alipay_sdk=alipay-sdk-java-3.3.0&amp;format=json^_^ApplicationParams:biz_content=&#123;"out_trade_no":"tradeprecreate15481691348134324306","seller_id":"","total_amount":"0.01","undiscountable_amount":"0","subject":"xxx品牌xxx门店当面付扫码消费","body":"购买商品3件共20.00元","goods_detail":[&#123;"goods_id":"goods_id001","goods_name":"xxx小面包","quantity":1,"price":"10"&#125;,&#123;"goods_id":"goods_id002","goods_name":"xxx牙刷","quantity":2,"price":"5"&#125;],"operator_id":"test_operator_id","store_id":"test_store_id","extend_params":&#123;"sys_service_provider_id":"2088100200300400500"&#125;,"timeout_express":"120m"&#125;^_^567ms,524ms,22ms一月 22, 2019 10:58:56 下午 com.alipay.demo.trade.service.impl.AbsAlipayService getResponse信息: &#123;"alipay_trade_precreate_response":&#123;"code":"10000","msg":"Success","out_trade_no":"tradeprecreate15481691348134324306","qr_code":"https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8"&#125;,"sign":"K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="&#125;一月 22, 2019 10:58:56 下午 com.alipay.demo.trade.Main test_trade_precreate信息: 支付宝预下单成功: )一月 22, 2019 10:58:56 下午 com.alipay.demo.trade.Main dumpResponse信息: code:10000, msg:Success一月 22, 2019 10:58:56 下午 com.alipay.demo.trade.Main dumpResponse信息: body:&#123;"alipay_trade_precreate_response":&#123;"code":"10000","msg":"Success","out_trade_no":"tradeprecreate15481691348134324306","qr_code":"https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8"&#125;,"sign":"K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="&#125;一月 22, 2019 10:58:56 下午 com.alipay.demo.trade.Main test_trade_precreate信息: filePath:/Users/sudo/Desktop/qr-tradeprecreate15481691348134324306.png 交易创建的参数 发送 123456789101112131415161718192021222324252627282930&#123; "out_trade_no": "tradeprecreate15481691348134324306", //外部交易订单号 "seller_id": "", //销售id "total_amount": "0.01", //总金额 "undiscountable_amount": "0", //不参加折扣的金额 "subject": "xxx品牌xxx门店当面付扫码消费", //标题 "body": "购买商品3件共20.00元", //购买说明 //商品详情 "goods_detail": [ &#123; "goods_id": "goods_id001", //商品id "goods_name": "xxx小面包", //商品名称 "quantity": 1, //商品数量 "price": "10" //商品单价 &#125;, &#123; "goods_id": "goods_id002", "goods_name": "xxx牙刷", "quantity": 2, "price": "5" &#125; ], "operator_id": "test_operator_id", //操作员的id "store_id": "test_store_id", //店铺id //扩展字段 "extend_params": &#123; "sys_service_provider_id": "2088100200300400500" //在回调时使用，交互时常用 &#125;, "timeout_express": "120m" //交易超时时间，120分钟&#125; 响应 1234567&#123; "code": "10000", //响应码 "msg": "Success", //信息 "out_trade_no": "tradeprecreate15481691348134324306", //外部交易订单号 "qr_code": "https:\/\/qr.alipay.com\/bax06491yqcl41q5rnzb00e8" //二维码，可以通过base64方式传给前端展示，或者将二维码上传到后台ftp服务器进行展示&#125;,"sign": "K68FrpzgPWkN2whVqVuzBLMr35h2TA/dm7VJWdoxsm/KIwsJS8bFI+hTe35bUP3C8Xu+lY4+SOuJdDZUQuM2P9NADt/lYViIigeWVy65BLcsU3qNKvBk/iAqY1zduXx3MjcxUzAUidpk6OnL6hG0uBPmYqlXL3u2jZB1FwdzmZo/iOjXq0Kg0I7tYUbiIIUy28he/dpxtaX7Iha5iHAB7nx0y0M7KoihmF8l6+sr9QGfm+N+DCqBWWQa336RieY/uxz/c8CF4Jexz8ahXf0/+EZJjA6+48umU3OL3lEnOgMoom2xB0IsEP0wsMI4HKagv/h21+YuaBH33CuzyyUkDQ=="&#125; 可以用二维码生成器将返回的qr_code生成，用支付宝沙箱版进行扫码支付测试 至此，支付宝当面付的官方demo就调通了，可以进行后续开发]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>支付宝</tag>
        <tag>当面付</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一篇博客]]></title>
    <url>%2F2019%2F01%2F18%2FFirst-Blog-Post%2F</url>
    <content type="text"><![CDATA[开篇新开一个个人博客用于知识管理，同时也会记录一些生活、想法、读书笔记等等。 以前一直在用有道云笔记进行知识管理，原因是同步起来十分方便，还可以跨平台跨设备，同时对markdown格式的支持比较友好。然而云笔记相比博客，缺少了分享和交流，同时博客也能用内容输出来促进自己的输入。]]></content>
      <categories>
        <category>记录</category>
      </categories>
  </entry>
</search>
